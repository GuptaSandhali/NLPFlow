<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLPFlow - Node Workflow Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Node registry and manifest for lazy-loading external nodes -->
    <script src="src/engine/registry.js"></script>
    <script src="src/nodes/manifest.js"></script>
    <!-- AI Builder utilities -->
    <script src="src/ai/graphValidator.js"></script>
    <script src="src/ai/manifestSummary.js"></script>
    <script src="src/ai/aiBuilderService.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #root {
            width: 100%;
            height: 100%;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background-color: #2b2b2b;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3e3e3e;
            z-index: 10;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            width: 280px;
            background-color: #252525;
            border-right: 1px solid #3e3e3e;
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #1a1a1a;
        }

        .properties-panel {
            width: 320px;
            background-color: #252525;
            border-left: 1px solid #3e3e3e;
            overflow-y: auto;
        }

        .workflow-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
        }

        .workflow-canvas.grabbing {
            cursor: grabbing;
        }

        .canvas-grid {
            position: absolute;
            width: 200%;
            height: 200%;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
        }

        .node {
            position: absolute;
            background: #2b2b2b;
            border: 1px solid #3e3e3e;
            border-radius: 8px;
            min-width: 220px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            cursor: move;
            user-select: none;
        }

        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3), 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .node-header {
            padding: 10px 12px;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            font-size: 14px;
            color: white;
            position: relative;
        }

        .node-execute {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            padding: 4px 8px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
            border-radius: 4px;
            color: #3b82f6;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .node-execute:hover {
            background: rgba(59, 130, 246, 0.3);
        }

        .node-execute:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .node-body {
            padding: 12px;
            font-size: 13px;
            color: #b3b3b3;
            min-height: 40px;
        }

        .node-preview {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 4px;
            margin-top: 8px;
            background: #1a1a1a;
            display: block;
            border: 1px solid #3e3e3e;
        }

        .node-debug-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #93c5fd;
        }

        .node-error-info {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #fca5a5;
        }

        .node-warning-info {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid #f59e0b;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #fbbf24;
        }

        .node-port {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a5568;
            border: 2px solid #2b2b2b;
            border-radius: 50%;
            cursor: pointer;
            z-index: 2;
        }

        .node-port:hover {
            background: #3b82f6;
        }

        .node-port.input {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .node-port.output {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .node-port.connected {
            background: #10b981;
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            stroke: #3b82f6;
            stroke-width: 2;
            fill: none;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #2b2b2b;
            border: 1px solid #3e3e3e;
            border-radius: 8px;
            padding: 8px;
            z-index: 5;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #3b3b3b;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 18px;
        }

        .zoom-btn:hover {
            background: #4b4b4b;
        }

        .execution-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2b2b2b;
            border: 1px solid #3e3e3e;
            border-radius: 8px;
            padding: 12px 16px;
            display: none;
            max-width: 300px;
            z-index: 5;
        }

        .execution-status.active {
            display: block;
        }

        .btn {
            padding: 8px 16px;
            background: #3b82f6;
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: #2563eb;
        }

        .btn.btn-stop {
            background: #ef4444;
        }

        .btn.btn-stop:hover {
            background: #dc2626;
        }

        .btn.btn-settings {
            background: #6b7280;
        }

        .btn.btn-settings:hover {
            background: #4b5563;
        }

        .search-box {
            padding: 12px;
            border-bottom: 1px solid #3e3e3e;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }

        .node-library {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .node-category {
            margin-bottom: 16px;
        }

        .node-category-title {
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .library-node {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #2b2b2b;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: grab;
        }

        .library-node:hover {
            background: #333333;
        }

        .property-group {
            padding: 16px;
            border-bottom: 1px solid #3e3e3e;
        }

        .property-label {
            font-size: 13px;
            color: #888;
            margin-bottom: 6px;
        }

        .property-input {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }

        .property-select {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }

        .property-slider {
            width: 100%;
            margin: 8px 0;
        }

        textarea.property-input {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .node-status-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: none;
            z-index: 3;
        }

        .node-status-indicator.success {
            background: #10b981;
            display: block;
        }

        .node-status-indicator.running {
            background: #3b82f6;
            display: block;
            animation: pulse 1.5s infinite;
        }

        .node-status-indicator.error {
            background: #ef4444;
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .file-upload-area {
            border: 2px dashed #3e3e3e;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            margin-top: 8px;
        }

        .file-upload-area:hover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .preview-image {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            margin-top: 12px;
            border-radius: 6px;
        }

        /* API Panel Styles */
        .api-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 400px;
            max-height: 600px;
            background: #2b2b2b;
            border: 1px solid #3e3e3e;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            display: none;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .api-panel.show {
            display: block;
        }

        .api-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #3e3e3e;
        }

        .api-panel-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #fff;
        }

        .api-section {
            margin-bottom: 24px;
        }

        .api-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #fff;
        }

        .api-description {
            font-size: 12px;
            color: #888;
            margin-bottom: 12px;
        }

        .api-link {
            color: #3b82f6;
            text-decoration: none;
        }

        .api-link:hover {
            text-decoration: underline;
        }

        .api-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .api-input {
            flex: 1;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .api-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }

        .api-status.connected {
            background: #10b981;
            color: white;
        }

        .api-status.error {
            background: #ef4444;
            color: white;
        }

        .test-btn {
            padding: 6px 12px;
            background: #4b5563;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        .test-btn:hover {
            background: #6b7280;
        }

        .success-message {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid #10b981;
            border-radius: 6px;
            padding: 10px;
            color: #86efac;
            font-size: 12px;
            margin-top: 8px;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 6px;
            padding: 10px;
            color: #fca5a5;
            font-size: 12px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Your API Keys (pre-configured)
        const DEFAULT_API_KEYS = {
            gemini: '',
            falai: '',
            falProxy: '',
            deepgram: 'cb4d4c3d9a15e6bbac0b35f7083a3ca4bbdafefe',
            openai: '',
            perplexity: '',
            perplexityProxy: ''
        };

        // API Configuration
        const API_STORAGE_KEY = 'thumbnail_generator_api_keys';
        const WORKFLOWS_STORAGE_KEY = 'nlpflow_workflows';

        const getStoredAPIKeys = () => {
            const stored = localStorage.getItem(API_STORAGE_KEY);
            if (stored) {
                return JSON.parse(stored);
            }
            saveAPIKeys(DEFAULT_API_KEYS);
            return DEFAULT_API_KEYS;
        };

        const saveAPIKeys = (keys) => {
            localStorage.setItem(API_STORAGE_KEY, JSON.stringify(keys));
        };

        // Node Icons
        const NodeIcons = {
            Type: '✏',
            Image: '🖼',
            Sparkles: '✨',
            Scissors: '✂',
            FileText: '📝',
            Layers: '📚',
            Download: '⬇',
            Settings: '⚙',
            Music: '🎵',
            MessageSquare: '💬',
            Eye: '👁'
        };

        // Node type definitions (from manifest)
        const nodeTypes = (window.NodeManifest && window.NodeManifest.types) || {};

        // API Panel Component
        function APIPanel({ isOpen, onClose, apiKeys, setApiKeys }) {
            const [tempKeys, setTempKeys] = useState(apiKeys);
            const [testStatus, setTestStatus] = useState({});

            const handleSave = () => {
                saveAPIKeys(tempKeys);
                setApiKeys(tempKeys);
                alert('API keys saved successfully!');
            };

            const testGeminiAPI = async () => {
                if (!tempKeys.gemini) {
                    setTestStatus(prev => ({ ...prev, gemini: 'error' }));
                    return;
                }

                setTestStatus(prev => ({ ...prev, gemini: 'testing' }));

                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-goog-api-key': tempKeys.gemini
                            },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [{ text: 'Test connection - create a small test image of a star' }]
                                }]
                            })
                        }
                    );

                    if (response.ok) {
                        setTestStatus(prev => ({ ...prev, gemini: 'success' }));
                    } else {
                        setTestStatus(prev => ({ ...prev, gemini: 'error' }));
                    }
                } catch (error) {
                    console.error('Gemini test error:', error);
                    setTestStatus(prev => ({ ...prev, gemini: 'error' }));
                }
            };

            const testFalAIAPI = async () => {
                if (!tempKeys.falai) {
                    setTestStatus(prev => ({ ...prev, falai: 'error' }));
                    return;
                }

                setTestStatus(prev => ({ ...prev, falai: 'testing' }));

                try {
                    // Simple test API call to FalAI
                    const response = await fetch(
                        'https://fal.run/fal-ai/fast-svd/text-to-video',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': `Key ${tempKeys.falai}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                prompt: 'test connection'
                            })
                        }
                    );

                    if (response.ok || response.status === 400) {
                        // 400 might mean valid key but bad request, which is fine for testing
                        setTestStatus(prev => ({ ...prev, falai: 'success' }));
                    } else if (response.status === 401 || response.status === 403) {
                        setTestStatus(prev => ({ ...prev, falai: 'error' }));
                    } else {
                        setTestStatus(prev => ({ ...prev, falai: 'success' }));
                    }
                } catch (error) {
                    console.error('FalAI test error:', error);
                    setTestStatus(prev => ({ ...prev, falai: 'error' }));
                }
            };

            const testDeepgramAPI = async () => {
                if (!tempKeys.deepgram) {
                    setTestStatus(prev => ({ ...prev, deepgram: 'error' }));
                    return;
                }

                setTestStatus(prev => ({ ...prev, deepgram: 'testing' }));

                try {
                    const response = await fetch('https://api.deepgram.com/v1/projects', {
                        method: 'GET',
                        headers: {
                            'Authorization': `Token ${tempKeys.deepgram}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        setTestStatus(prev => ({ ...prev, deepgram: 'success' }));
                    } else {
                        setTestStatus(prev => ({ ...prev, deepgram: 'error' }));
                    }
                } catch (error) {
                    console.error('Deepgram test error:', error);
                    setTestStatus(prev => ({ ...prev, deepgram: 'error' }));
                }
            };

            const testOpenAIAPI = async () => {
                if (!tempKeys.openai) {
                    setTestStatus(prev => ({ ...prev, openai: 'error' }));
                    return;
                }

                setTestStatus(prev => ({ ...prev, openai: 'testing' }));

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${tempKeys.openai}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{ role: 'user', content: 'Test connection - respond with "OK"' }],
                            max_tokens: 5
                        })
                    });

                    if (response.ok) {
                        setTestStatus(prev => ({ ...prev, openai: 'success' }));
                    } else {
                        setTestStatus(prev => ({ ...prev, openai: 'error' }));
                    }
                } catch (error) {
                    console.error('OpenAI test error:', error);
                    setTestStatus(prev => ({ ...prev, openai: 'error' }));
                }
            };

            const testPerplexityAPI = async () => {
                if (!tempKeys.perplexity) {
                    setTestStatus(prev => ({ ...prev, perplexity: 'error' }));
                    return;
                }
                setTestStatus(prev => ({ ...prev, perplexity: 'testing' }));
                try {
                    const base = tempKeys.perplexityProxy || 'https://api.perplexity.ai';
                    const res = await fetch(`${base.replace(/\/$/, '')}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${tempKeys.perplexity}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'sonar-small',
                            temperature: 0,
                            max_tokens: 10,
                            messages: [
                                { role: 'system', content: 'Reply with OK only.' },
                                { role: 'user', content: 'Test' }
                            ]
                        })
                    });
                    // Consider 200 OK as success. Also treat certain 4xx as success (key recognized but bad payload).
                    if (res.ok || res.status === 400 || res.status === 404 || res.status === 422) {
                        setTestStatus(prev => ({ ...prev, perplexity: 'success' }));
                    } else if (res.status === 401 || res.status === 403) {
                        setTestStatus(prev => ({ ...prev, perplexity: 'error' }));
                    } else {
                        // Other statuses are inconclusive; mark success to avoid blocking, and show console note
                        console.warn('Perplexity test returned non-OK status:', res.status);
                        setTestStatus(prev => ({ ...prev, perplexity: 'success' }));
                    }
                } catch (e) {
                    // Likely CORS/network issue in browser. If key format looks valid, mark success.
                    const looksValid = /^pplx-/.test(tempKeys.perplexity);
                    console.warn('Perplexity test likely blocked by CORS. Configure a proxy in API settings.', e);
                    setTestStatus(prev => ({ ...prev, perplexity: looksValid ? 'success' : 'error' }));
                }
            };

            return (
                <div className={`api-panel ${isOpen ? 'show' : ''}`}>
                    <div className="api-panel-header">
                        <div className="api-panel-title">API Settings</div>
                        <button className="close-btn" onClick={onClose}>×</button>
                    </div>

                    <div className="api-section">
                        <div className="api-title">
                            Google Gemini API Key
                            {testStatus.gemini === 'success' && <span className="api-status connected">Connected</span>}
                            {testStatus.gemini === 'error' && <span className="api-status error">Failed</span>}
                        </div>
                        <div className="api-description">
                            For AI image generation. Get key from{' '}
                            <a href="https://makersuite.google.com/app/apikey" target="_blank" className="api-link">
                                Google AI Studio
                            </a>
                        </div>
                        <div className="api-input-group">
                            <input
                                type="password"
                                className="api-input"
                                placeholder="Enter Gemini API key..."
                                value={tempKeys.gemini || ''}
                                onChange={(e) => setTempKeys({ ...tempKeys, gemini: e.target.value })}
                            />
                            <button className="test-btn" onClick={testGeminiAPI}>
                                Test
                            </button>
                        </div>
                        {testStatus.gemini === 'success' && (
                            <div className="success-message">✓ API key is valid and working!</div>
                        )}
                        {testStatus.gemini === 'error' && (
                            <div className="error-message">✗ Invalid API key or connection failed</div>
                        )}
                    </div>

                    <div className="api-section">
                        <div className="api-title">
                            Perplexity API Key
                            {testStatus.perplexity === 'success' && <span className="api-status connected">Connected</span>}
                            {testStatus.perplexity === 'error' && <span className="api-status error">Failed</span>}
                        </div>
                        <div className="api-description">
                            For entity search using Perplexity. Endpoint is OpenAI-compatible.
                        </div>
                        <input
                            className="property-input"
                            type="password"
                            placeholder="perplexity key (pplx-...)"
                            value={tempKeys.perplexity || ''}
                            onChange={(e) => setTempKeys(prev => ({ ...prev, perplexity: e.target.value }))}
                            style={{ marginBottom: '8px' }}
                        />
                        <input
                            className="property-input"
                            type="text"
                            placeholder="Optional proxy base URL (e.g., https://your-proxy.example.com)"
                            value={tempKeys.perplexityProxy || ''}
                            onChange={(e) => setTempKeys(prev => ({ ...prev, perplexityProxy: e.target.value }))}
                            style={{ marginBottom: '8px' }}
                        />
                        <div style={{ fontSize: '12px', color: '#888', marginTop: '6px', marginBottom: '8px' }}>
                            Tip: Browser requests may be blocked by CORS. If the test keeps failing, set a proxy URL that forwards to https://api.perplexity.ai with CORS enabled.
                        </div>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button className="btn" onClick={testPerplexityAPI}>Test Connection</button>
                        </div>
                    </div>

                    <div className="api-section">
                        <div className="api-title">
                            FalAI API Key
                            {testStatus.falai === 'success' && <span className="api-status connected">Connected</span>}
                            {testStatus.falai === 'error' && <span className="api-status error">Failed</span>}
                        </div>
                        <div className="api-description">
                            For BRIA background removal. Get key from{' '}
                            <a href="https://fal.ai/dashboard/keys" target="_blank" className="api-link">
                                FalAI Dashboard
                            </a>
                        </div>
                        <div className="api-input-group">
                            <input
                                type="password"
                                className="api-input"
                                placeholder="Enter FalAI API key..."
                                value={tempKeys.falai || ''}
                                onChange={(e) => setTempKeys({ ...tempKeys, falai: e.target.value })}
                            />
                            <button className="test-btn" onClick={testFalAIAPI}>
                                Test
                            </button>
                        </div>
                        <input
                            className="property-input"
                            type="text"
                            placeholder="Optional Fal proxy base URL (e.g., https://your-proxy.example.com)"
                            value={tempKeys.falProxy || ''}
                            onChange={(e) => setTempKeys(prev => ({ ...prev, falProxy: e.target.value }))}
                            style={{ marginTop: '8px' }}
                        />
                        <div style={{ fontSize: '12px', color: '#888', marginTop: '6px' }}>
                            Tip: If browser requests are blocked by CORS, set a proxy base that forwards to https://fal.run and https://queue.fal.run with CORS enabled.
                        </div>
                        {testStatus.falai === 'success' && (
                            <div className="success-message">✓ FalAI API key is valid and working!</div>
                        )}
                        {testStatus.falai === 'error' && (
                            <div className="error-message">✗ Invalid FalAI API key or connection failed</div>
                        )}
                    </div>

                    <div className="api-section">
                        <div className="api-title">
                            Deepgram API Key
                            {testStatus.deepgram === 'success' && <span className="api-status connected">Connected</span>}
                            {testStatus.deepgram === 'error' && <span className="api-status error">Failed</span>}
                        </div>
                        <div className="api-description">
                            For audio transcription. Get key from{' '}
                            <a href="https://console.deepgram.com/" target="_blank" className="api-link">
                                Deepgram Console
                            </a>
                        </div>
                        <div className="api-input-group">
                            <input
                                type="password"
                                className="api-input"
                                placeholder="Enter Deepgram API key..."
                                value={tempKeys.deepgram || ''}
                                onChange={(e) => setTempKeys({ ...tempKeys, deepgram: e.target.value })}
                            />
                            <button className="test-btn" onClick={testDeepgramAPI}>
                                Test
                            </button>
                        </div>
                        {testStatus.deepgram === 'testing' && (
                            <div className="testing-message">Testing API key...</div>
                        )}
                        {testStatus.deepgram === 'success' && (
                            <div className="success-message">✓ Deepgram API key is valid and working!</div>
                        )}
                        {testStatus.deepgram === 'error' && (
                            <div className="error-message">✗ Invalid Deepgram API key or connection failed</div>
                        )}
                    </div>

                    <div className="api-section">
                        <div className="api-title">
                            OpenAI API Key
                            {testStatus.openai === 'success' && <span className="api-status connected">Connected</span>}
                            {testStatus.openai === 'error' && <span className="api-status error">Failed</span>}
                        </div>
                        <div className="api-description">
                            For GPT chat completions. Get key from{' '}
                            <a href="https://platform.openai.com/api-keys" target="_blank" className="api-link">
                                OpenAI Platform
                            </a>
                        </div>
                        <div className="api-input-group">
                            <input
                                type="password"
                                className="api-input"
                                placeholder="Enter OpenAI API key..."
                                value={tempKeys.openai || ''}
                                onChange={(e) => setTempKeys({ ...tempKeys, openai: e.target.value })}
                            />
                            <button className="test-btn" onClick={testOpenAIAPI}>
                                Test
                            </button>
                        </div>
                        {testStatus.openai === 'testing' && (
                            <div className="testing-message">Testing API key...</div>
                        )}
                        {testStatus.openai === 'success' && (
                            <div className="success-message">✓ OpenAI API key is valid and working!</div>
                        )}
                        {testStatus.openai === 'error' && (
                            <div className="error-message">✗ Invalid OpenAI API key or connection failed</div>
                        )}
                    </div>

                    <div style={{ display: 'flex', gap: '12px', marginTop: '20px' }}>
                        <button className="btn" onClick={handleSave} style={{ flex: 1 }}>
                            💾 Save API Keys
                        </button>
                        <button className="btn btn-settings" onClick={onClose} style={{ flex: 1 }}>
                            Cancel
                        </button>
                    </div>
                </div>
            );
        }

        // AI Builder Panel (MVP)
        function AIBuilderPanel({ isOpen, onClose, apiKeys, nodes, connections, addNode, updateNodeParameters, setConnections }) {
            const [intent, setIntent] = useState('Make a YouTube thumbnail with bold SALE text and a product photo.');
            const [includeContext, setIncludeContext] = useState(true);
            const [busy, setBusy] = useState(false);
            const [result, setResult] = useState(null);
            const [validation, setValidation] = useState(null);
            const [provider, setProvider] = useState('perplexity');

            const currentGraph = includeContext ? {
                nodes: nodes.map(n => ({ id: n.id, type: n.type, params: n.parameters || {} })),
                edges: connections.map(c => ({ from: c.from, to: c.to }))
            } : null;

            const handleGenerate = async () => {
                setBusy(true);
                setResult(null);
                setValidation(null);
                try {
                    const manifestSummary = window.ManifestSummary.summarizeManifest(window.NodeManifest.types);
                    const out = await window.AIBuilderService.generateGraph({
                        intent,
                        manifestSummary,
                        currentGraph,
                        apiKeys,
                        provider
                    });
                    const graph = out.graph || { nodes: [], edges: [] };
                    const v = window.GraphValidator.validateGraph(graph, window.NodeManifest.types);
                    setResult({ ...out, graph });
                    setValidation(v);
                } catch (e) {
                    setResult({ error: e.message });
                } finally {
                    setBusy(false);
                }
            };

            const layoutNodes = (g) => {
                // Simple left-to-right layout by topological sort
                const ids = g.nodes.map(n => n.id);
                const indeg = Object.fromEntries(ids.map(id => [id, 0]));
                g.edges.forEach(e => { if (indeg[e.to] !== undefined) indeg[e.to]++; });
                const queue = ids.filter(id => indeg[id] === 0);
                const order = [];
                const adj = {};
                ids.forEach(id => { adj[id] = []; });
                g.edges.forEach(e => { if (adj[e.from]) adj[e.from].push(e.to); });
                while (queue.length) {
                    const id = queue.shift();
                    order.push(id);
                    (adj[id] || []).forEach(v => { indeg[v]--; if (indeg[v] === 0) queue.push(v); });
                }
                const pos = {};
                const colWidth = 280, rowHeight = 180;
                order.forEach((id, idx) => {
                    const col = idx;
                    pos[id] = [120 + col * colWidth, 140 + (idx % 3) * rowHeight];
                });
                g.nodes.forEach((n, i) => { if (!pos[n.id]) pos[n.id] = [120 + (i % 4) * colWidth, 140 + Math.floor(i / 4) * rowHeight]; });
                return pos;
            };

            const applyGraph = () => {
                if (!result || !result.graph) return;
                const g = result.graph;
                const positions = layoutNodes(g);
                const idMap = new Map();
                const existingIds = new Set(nodes.map(n => n.id));
                const ensureUniqueId = (baseId) => {
                    let id = baseId;
                    let i = 2;
                    while (existingIds.has(id)) { id = `${baseId}-${i++}`; }
                    existingIds.add(id);
                    return id;
                };
                // Add nodes with stable ids
                g.nodes.forEach(n => {
                    const targetId = existingIds.has(n.id) ? ensureUniqueId(n.id) : n.id;
                    const newId = addNode(n.type, positions[n.id], targetId);
                    idMap.set(n.id, newId);
                    if (n.params) updateNodeParameters(newId, n.params);
                });
                // Add edges
                const canvasIds = new Set([...existingIds]);
                const edgeCandidates = g.edges.map(e => ({
                    id: `conn-${Date.now()}-${Math.random().toString(36).slice(2,6)}`,
                    from: idMap.get(e.from) || e.from,
                    to: idMap.get(e.to) || e.to,
                    slot: typeof e.slot !== 'undefined' ? e.slot : undefined
                }));
                const filteredEdges = edgeCandidates.filter(e => canvasIds.has(e.from) && canvasIds.has(e.to));
                const dropped = edgeCandidates.length - filteredEdges.length;
                setConnections(prev => [...prev, ...filteredEdges]);
                if (dropped > 0) {
                    alert(`⚠️ Skipped ${dropped} edge(s) referencing unknown nodes after apply.`);
                }
                onClose();
            };

            const applyExecutableSubgraph = () => {
                if (!result || !result.graph || !validation) return;
                const placeholderIds = new Set(validation.placeholders.map(p => p.id));
                const filtered = {
                    nodes: result.graph.nodes.filter(n => !placeholderIds.has(n.id)),
                    edges: result.graph.edges.filter(e => !placeholderIds.has(e.from) && !placeholderIds.has(e.to))
                };
                const g = filtered;
                const positions = layoutNodes(g);
                const idMap = new Map();
                const existingIds = new Set(nodes.map(n => n.id));
                const ensureUniqueId = (baseId) => {
                    let id = baseId;
                    let i = 2;
                    while (existingIds.has(id)) { id = `${baseId}-${i++}`; }
                    existingIds.add(id);
                    return id;
                };
                g.nodes.forEach(n => {
                    const targetId = existingIds.has(n.id) ? ensureUniqueId(n.id) : n.id;
                    const newId = addNode(n.type, positions[n.id], targetId);
                    idMap.set(n.id, newId);
                    if (n.params) updateNodeParameters(newId, n.params);
                });
                const canvasIds = new Set([...existingIds]);
                const edgeCandidates = g.edges.map(e => ({
                    id: `conn-${Date.now()}-${Math.random().toString(36).slice(2,6)}`,
                    from: idMap.get(e.from) || e.from,
                    to: idMap.get(e.to) || e.to,
                    slot: typeof e.slot !== 'undefined' ? e.slot : undefined
                }));
                const filteredEdges = edgeCandidates.filter(e => canvasIds.has(e.from) && canvasIds.has(e.to));
                const dropped = edgeCandidates.length - filteredEdges.length;
                setConnections(prev => [...prev, ...filteredEdges]);
                if (dropped > 0) {
                    alert(`⚠️ Skipped ${dropped} edge(s) referencing unknown nodes after apply.`);
                }
                onClose();
            };

            return (
                <div className={`api-panel ${isOpen ? 'show' : ''}`}>
                    <div className="api-panel-header">
                        <div className="api-panel-title">🤖 AI Builder (Chat → Graph)</div>
                        <button className="close-btn" onClick={onClose}>×</button>
                    </div>

                    <div className="api-section">
                        <div className="api-title">Describe your workflow</div>
                        <textarea className="property-input" style={{ height: '88px', resize: 'vertical' }} value={intent} onChange={(e) => setIntent(e.target.value)} placeholder="e.g., Generate a banner: text prompt → AI image → overlay heading → export PNG" />
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' }}>
                            <span style={{ fontSize: '12px', color: '#aaa' }}>Provider:</span>
                            <label style={{ fontSize: '12px', color: '#ccc' }}>
                                <input type="radio" name="provider" value="perplexity" checked={provider === 'perplexity'} onChange={() => setProvider('perplexity')} /> Perplexity
                            </label>
                            <label style={{ fontSize: '12px', color: '#ccc' }}>
                                <input type="radio" name="provider" value="openai" checked={provider === 'openai'} onChange={() => setProvider('openai')} /> OpenAI (GPT)
                            </label>
                        </div>
                        <label style={{ display: 'flex', alignItems: 'center', gap: '8px', fontSize: '12px', color: '#aaa', marginTop: '8px' }}>
                            <input type="checkbox" checked={includeContext} onChange={(e) => setIncludeContext(e.target.checked)} />
                            Use current canvas as context
                        </label>
                        <div style={{ display: 'flex', gap: '8px', marginTop: '8px' }}>
                            <button className="btn" onClick={handleGenerate} disabled={busy}>{busy ? '⏳ Generating...' : 'Generate'}</button>
                        </div>
                        {provider === 'perplexity' && !apiKeys.perplexity && (
                            <div className="error-message" style={{ marginTop: '8px' }}>
                                No Perplexity key set; using heuristic fallback. Set key in API Settings for best results.
                            </div>
                        )}
                        {provider === 'openai' && !apiKeys.openai && (
                            <div className="error-message" style={{ marginTop: '8px' }}>
                                No OpenAI key set; using heuristic fallback. Set key in API Settings for best results.
                            </div>
                        )}
                    </div>

                    {result && result.error && (
                        <div className="error-message">{String(result.error)}</div>
                    )}

                    {result && result.graph && (
                        <div className="api-section">
                            <div className="api-title">Proposed Graph</div>
                            {result.notes && (
                                <div className="error-message" style={{ marginBottom: '8px' }}>{result.notes}</div>
                            )}
                            <pre style={{ maxHeight: '160px', overflow: 'auto', background: '#1f1f1f', padding: '8px', borderRadius: '6px', fontSize: '11px' }}>{JSON.stringify(result.graph, null, 2)}</pre>
                            {validation && (
                                <div style={{ marginTop: '8px' }}>
                                    {(!validation.ok || validation.placeholders.length > 0) && (
                                        <div className="error-message">
                                            {validation.errors.length} errors, {validation.warnings.length} warnings, {validation.placeholders.length} placeholders
                                        </div>
                                    )}
                                    {validation.ok && validation.warnings.length > 0 && (
                                        <div className="success-message">Graph is valid with {validation.warnings.length} warnings.</div>
                                    )}
                                </div>
                            )}

                            <div style={{ display: 'flex', gap: '8px', marginTop: '8px', flexWrap: 'wrap' }}>
                                <button className="btn" onClick={applyGraph} disabled={!validation || !validation.ok}>Apply to Canvas</button>
                                {validation && validation.placeholders.length > 0 && (
                                    <button className="btn" onClick={applyExecutableSubgraph}>Apply Executable Subgraph</button>
                                )}
                                {result.proposedNodes && result.proposedNodes.length > 0 && (
                                    <button className="btn" onClick={() => {
                                        const queueKey = 'aiNodeRequests';
                                        const existing = JSON.parse(localStorage.getItem(queueKey) || '[]');
                                        const ticket = {
                                            id: `req-${Date.now()}`,
                                            intent,
                                            proposedNodes: result.proposedNodes,
                                            createdAt: new Date().toISOString()
                                        };
                                        localStorage.setItem(queueKey, JSON.stringify([ticket, ...existing]));
                                        alert('✅ Request captured locally. You can export it later.');
                                    }}>Request Missing Nodes</button>
                                )}
                                <button className="btn btn-stop" onClick={onClose}>Cancel</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // Main App Component
        function ThumbnailGenerator() {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [isExecuting, setIsExecuting] = useState(false);
            const [executingNode, setExecutingNode] = useState(null);
            const [executionProgress, setExecutionProgress] = useState(0);
            const [executionMessage, setExecutionMessage] = useState('');
            const [zoom, setZoom] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [draggedNode, setDraggedNode] = useState(null);
            const [isPanning, setIsPanning] = useState(false);
            const [startPan, setStartPan] = useState({ x: 0, y: 0 });
            const [isConnecting, setIsConnecting] = useState(false);
            const [connectingFrom, setConnectingFrom] = useState(null);
            const [tempConnection, setTempConnection] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [apiKeys, setApiKeys] = useState(getStoredAPIKeys());
            const [showAPIPanel, setShowAPIPanel] = useState(false);
            const canvasRef = useRef(null);

            // Handle canvas pan
            const handleCanvasMouseDown = (e) => {
                if (e.target.classList.contains('workflow-canvas') || e.target.classList.contains('canvas-grid')) {
                    setIsPanning(true);
                    setStartPan({ x: e.clientX - pan.x, y: e.clientY - pan.y });
                    e.preventDefault();
                }
            };

            const handleCanvasMouseMove = (e) => {
                if (!canvasRef.current) return;

                if (isPanning) {
                    setPan({ x: e.clientX - startPan.x, y: e.clientY - startPan.y });
                }

                if (isConnecting && connectingFrom) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = (e.clientX - rect.left - pan.x) / zoom;
                    const y = (e.clientY - rect.top - pan.y) / zoom;
                    setTempConnection({ from: connectingFrom, to: { x, y } });
                }
            };

            const handleCanvasMouseUp = () => {
                setIsPanning(false);
                if (isConnecting) {
                    setIsConnecting(false);
                    setConnectingFrom(null);
                    setTempConnection(null);
                }
            };

            // Node dragging
            const handleNodeMouseDown = (e, nodeId) => {
                e.stopPropagation();
                setDraggedNode(nodeId);
                setSelectedNode(nodeId);
                const rect = e.currentTarget.getBoundingClientRect();
                setIsDragging({
                    offsetX: e.clientX - rect.left,
                    offsetY: e.clientY - rect.top
                });
            };

            const handleNodeDrag = (e) => {
                if (isDragging && draggedNode && canvasRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = (e.clientX - rect.left - pan.x) / zoom - isDragging.offsetX;
                    const y = (e.clientY - rect.top - pan.y) / zoom - isDragging.offsetY;

                    setNodes(prevNodes =>
                        prevNodes.map(node =>
                            node.id === draggedNode
                                ? { ...node, position: [x, y] }
                                : node
                        )
                    );
                }
            };

            const handleNodeMouseUp = () => {
                setIsDragging(false);
                setDraggedNode(null);
            };

            // Connection handling
            const handlePortClick = (e, nodeId, portType) => {
                e.stopPropagation();

                if (portType === 'output') {
                    setIsConnecting(true);
                    setConnectingFrom({ nodeId, port: 'output' });
                } else if (isConnecting && connectingFrom && portType === 'input') {
                    const newConnection = {
                        id: `conn-${Date.now()}`,
                        from: connectingFrom.nodeId,
                        to: nodeId
                    };
                    setConnections(prev => [...prev, newConnection]);
                    setIsConnecting(false);
                    setConnectingFrom(null);
                    setTempConnection(null);
                }
            };

            // Add new node
            const addNode = (type, position = [400, 300], customId = null) => {
                const newNode = {
                    id: customId || `node-${Date.now()}`,
                    type: type,
                    position: position,
                    name: nodeTypes[type].name,
                    parameters: getDefaultParameters(type),
                    status: 'idle',
                    outputData: null,
                    debugInfo: null
                };
                setNodes(prev => [...prev, newNode]);
                setSelectedNode(newNode.id);
                return newNode.id;
            };

            // Workflows: save/load/clear
            const getWorkflowSnapshot = () => ({
                nodes: nodes.map(n => ({ id: n.id, type: n.type, position: n.position, name: n.name, parameters: n.parameters })),
                connections: connections.map(c => ({ from: c.from, to: c.to }))
            });

            const [savedWorkflows, setSavedWorkflows] = useState(() => {
                try {
                    const raw = localStorage.getItem(WORKFLOWS_STORAGE_KEY);
                    return raw ? Object.keys(JSON.parse(raw)) : [];
                } catch { return []; }
            });

            const persistWorkflows = (obj) => {
                localStorage.setItem(WORKFLOWS_STORAGE_KEY, JSON.stringify(obj));
                setSavedWorkflows(Object.keys(obj));
            };

            const saveWorkflow = () => {
                const name = prompt('Save workflow as:');
                if (!name) return;
                const snapshot = getWorkflowSnapshot();
                let store = {};
                try { store = JSON.parse(localStorage.getItem(WORKFLOWS_STORAGE_KEY) || '{}'); } catch {}
                store[name] = { snapshot, savedAt: new Date().toISOString() };
                persistWorkflows(store);
                alert(`✅ Saved workflow "${name}"`);
            };

            const loadWorkflow = (name) => {
                if (!name) return;
                let store = {};
                try { store = JSON.parse(localStorage.getItem(WORKFLOWS_STORAGE_KEY) || '{}'); } catch {}
                const entry = store[name];
                if (!entry) { alert('Not found'); return; }
                const snap = entry.snapshot || entry; // backward tolerant
                const manifest = window.NodeManifest && window.NodeManifest.types;
                // Filter nodes whose type still exists
                const filteredNodes = (snap.nodes || []).filter(n => manifest[n.type]);
                const ids = new Set(filteredNodes.map(n => n.id));
                const filteredEdges = (snap.connections || []).filter(e => ids.has(e.from) && ids.has(e.to));
                setNodes(filteredNodes.map(n => ({ ...n, status: 'idle', outputData: null, debugInfo: null })));
                setConnections(filteredEdges.map((e, i) => ({ id: `conn-load-${i}-${Date.now()}`, ...e })));
                setSelectedNode(null);
                alert(`✅ Loaded workflow "${name}"`);
            };

            const deleteWorkflow = (name) => {
                if (!name) return;
                if (!confirm(`Delete saved workflow "${name}"?`)) return;
                let store = {};
                try { store = JSON.parse(localStorage.getItem(WORKFLOWS_STORAGE_KEY) || '{}'); } catch {}
                delete store[name];
                persistWorkflows(store);
            };

            const clearCanvas = () => {
                if (!confirm('Clear all nodes and connections?')) return;
                setNodes([]);
                setConnections([]);
                setSelectedNode(null);
            };

            // Get default parameters from manifest (lightweight)
            const getDefaultParameters = (type) => {
                const manifest = window.NodeManifest && window.NodeManifest.types;
                return (manifest && manifest[type] && manifest[type].defaults) || {};
            };

            // Update node parameters
            const updateNodeParameters = (nodeId, parameters) => {
                setNodes(prev =>
                    prev.map(node =>
                        node.id === nodeId
                            ? { ...node, parameters: { ...node.parameters, ...parameters } }
                            : node
                    )
                );
            };

            // Delete node
            const deleteNode = (nodeId) => {
                setNodes(prev => prev.filter(n => n.id !== nodeId));
                setConnections(prev => prev.filter(c => c.from !== nodeId && c.to !== nodeId));
                setSelectedNode(null);
            };

            // Check if node has required inputs (io-aware)
            const hasRequiredInputs = (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node) return true;
                const m = nodeTypes[node.type] || {};
                if (!m.requiresInput) return true;
                const io = m.io || { inputTypes: [], inputMode: 'single' };
                const mode = io.inputMode || 'single';
                const declaredInputs = Array.isArray(io.inputTypes) ? io.inputTypes : [];
                const nonOptionalCount = declaredInputs.filter(t => !t || !t.optional).length;
                const minInputs = typeof io.minInputs === 'number' ? io.minInputs : (mode === 'multi' ? nonOptionalCount : 1);
                const incoming = connections.filter(c => c.to === nodeId).length;
                if (mode === 'single') return incoming >= 1;
                if (mode === 'variadic') return incoming >= (typeof io.minInputs === 'number' ? io.minInputs : 1);
                // multi
                return incoming >= minInputs;
            };

            // Get all input data for a node (order-aware via optional 'slot' on connections)
            const getInputDataForNode = (nodeId) => {
                let inputConnections = connections.filter(c => c.to === nodeId);
                if (inputConnections.length === 0) return null;

                // If slots are provided on any connection, sort by slot asc
                const anySlots = inputConnections.some(c => typeof c.slot !== 'undefined');
                if (anySlots) {
                    inputConnections = inputConnections.slice().sort((a, b) => {
                        const A = (typeof a.slot === 'number') ? a.slot : Number.MAX_SAFE_INTEGER;
                        const B = (typeof b.slot === 'number') ? b.slot : Number.MAX_SAFE_INTEGER;
                        return A - B;
                    });
                }

                // Single-input convenience: return the single upstream datum
                if (inputConnections.length === 1) {
                    const sourceNode = nodes.find(n => n.id === inputConnections[0].from);
                    return sourceNode ? sourceNode.outputData : null;
                }

                // Multi-input: return an ordered array of upstream data
                const inputs = [];
                inputConnections.forEach(conn => {
                    const sourceNode = nodes.find(n => n.id === conn.from);
                    if (sourceNode?.outputData) {
                        inputs.push(sourceNode.outputData);
                    } else {
                        inputs.push(null);
                    }
                });
                // If all nulls, return null to indicate missing inputs
                const allNull = inputs.every(x => x == null);
                return allNull ? null : inputs;
            };

            // Process individual node with robust input validation
            const processNode = async (node) => {
                console.log(`🔄 Processing ${node.type} node:`, node.parameters);
                setExecutionMessage(`Processing ${node.name}...`);

                // Update debug info to show what inputs we have
                const inputData = getInputDataForNode(node.id);
                const debugInfo = {
                    hasInput: !!inputData,
                    inputType: inputData?.type || 'none',
                    inputPreview: inputData?.text?.substring(0, 50) || inputData?.fileName || inputData?.preview || 'no input'
                };

                setNodes(prev =>
                    prev.map(n =>
                        n.id === node.id ? { ...n, debugInfo } : n
                    )
                );

                try {
                    // Execute via NodeRegistry (lazy-loaded). No inline fallback.
                    if (!window.NodeRegistry) {
                        throw new Error('NodeRegistry not available');
                    }
                    await window.NodeRegistry.ensureLoaded(node.type);
                    return await window.NodeRegistry.execute(node.type, {
                        node,
                        params: node.parameters,
                        inputData,
                        apiKeys,
                        setExecutionMessage,
                        updateNodeParameters
                    });
                    /*
                            await new Promise(resolve => setTimeout(resolve, 300));
                            return {
                                prompt: promptText.trim(),
                                type: 'prompt',
                                preview: promptText.substring(0, 100)
                            };
                        }

                        case 'imageInput':
                            const imageData = node.parameters.imageData;
                            if (!imageData) {
                                throw new Error('No image uploaded. Please upload an image first.');
                            }
                            return {
                                image: imageData,
                                fileName: node.parameters.fileName,
                                type: 'image',
                                preview: node.parameters.fileName
                            };

                        case 'audioInput':
                            const audioFile = node.parameters.audioFile;
                            if (!audioFile) {
                                throw new Error('No audio file uploaded. Please upload an audio file first.');
                            }
                            return {
                                audioFile: audioFile,
                                fileName: node.parameters.audioFileName,
                                type: 'audio',
                                preview: node.parameters.audioFileName || 'Audio file'
                            };

                        case 'geminiText2Image':
                            // STRICT input validation
                            if (!inputData) {
                                throw new Error('❌ No prompt connected! Connect a Prompt Input node to this Gemini Generate node.');
                            }

                            if (inputData.type !== 'prompt') {
                                throw new Error(`❌ Wrong input type! Expected prompt, got ${inputData.type}. Connect a Prompt Input node.`);
                            }

                            const prompt = inputData.prompt;
                            if (!prompt || prompt.trim() === '') {
                                throw new Error('❌ Empty prompt received! Make sure your Prompt Input node has text.');
                            }

                            console.log(`✅ Using prompt: "${prompt}"`);

                            // Create generated image with the actual prompt
                            const canvas = document.createElement('canvas');
                            canvas.width = node.parameters.aspectRatio === '16:9' ? 1920 :
                                          node.parameters.aspectRatio === '1:1' ? 1080 : 864;
                            canvas.height = node.parameters.aspectRatio === '16:9' ? 1080 :
                                           node.parameters.aspectRatio === '1:1' ? 1080 : 1080;
                            const ctx = canvas.getContext('2d');

                            // Random gradient based on prompt content
                            const colors = [
                                ['#667eea', '#764ba2'], // Purple
                                ['#f093fb', '#f5576c'], // Pink
                                ['#4facfe', '#00f2fe'], // Blue
                                ['#43e97b', '#38f9d7'], // Green
                                ['#fa709a', '#fee140'], // Orange
                                ['#30cfd0', '#c43bad']  // Cyan-Purple
                            ];

                            // Choose colors based on prompt keywords
                            let colorIndex = 0;
                            if (prompt.toLowerCase().includes('gaming') || prompt.toLowerCase().includes('neon')) colorIndex = 1;
                            else if (prompt.toLowerCase().includes('nature') || prompt.toLowerCase().includes('green')) colorIndex = 3;
                            else if (prompt.toLowerCase().includes('ocean') || prompt.toLowerCase().includes('blue')) colorIndex = 2;
                            else if (prompt.toLowerCase().includes('fire') || prompt.toLowerCase().includes('red')) colorIndex = 4;
                            else colorIndex = Math.floor(Math.random() * colors.length);

                            const colorPair = colors[colorIndex];

                            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                            gradient.addColorStop(0, colorPair[0]);
                            gradient.addColorStop(1, colorPair[1]);
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Add dynamic pattern based on prompt
                            ctx.globalAlpha = 0.1;
                            ctx.fillStyle = '#ffffff';
                            const patternCount = prompt.toLowerCase().includes('complex') ? 30 : 15;
                            for (let i = 0; i < patternCount; i++) {
                                const x = Math.random() * canvas.width;
                                const y = Math.random() * canvas.height;
                                const size = Math.random() * 80 + 40;
                                ctx.beginPath();
                                ctx.arc(x, y, size, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1;

                            // Add text with the actual prompt
                            ctx.fillStyle = '#ffffff';
                            ctx.font = 'bold 48px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0.5)';
                            ctx.shadowBlur = 10;
                            ctx.fillText('AI GENERATED', canvas.width / 2, canvas.height / 2 - 60);

                            // Display the actual prompt
                            ctx.font = '28px Arial';
                            const maxWidth = canvas.width - 100;
                            const words = prompt.split(' ');
                            let line = '';
                            let y = canvas.height / 2;

                            words.forEach((word, i) => {
                                const testLine = line + word + ' ';
                                const metrics = ctx.measureText(testLine);

                                if (metrics.width > maxWidth && i > 0) {
                                    ctx.fillText(line.trim(), canvas.width / 2, y);
                                    line = word + ' ';
                                    y += 35;
                                } else {
                                    line = testLine;
                                }
                            });
                            ctx.fillText(line.trim(), canvas.width / 2, y);

                            // Try Gemini 2.5 Flash Image API for actual image generation
                            if (apiKeys.gemini) {
                                try {
                                    setExecutionMessage(`🎨 Generating real image with Gemini 2.5 Flash Image: "${prompt.substring(0, 30)}..."`);

                                    const imageGenResponse = await fetch(
                                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent`,
                                        {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                                'x-goog-api-key': apiKeys.gemini
                                            },
                                            body: JSON.stringify({
                                                contents: [{
                                                    parts: [{
                                                        text: `Create a stunning, high-quality ${node.parameters.aspectRatio === '16:9' ? 'widescreen' : node.parameters.aspectRatio === '1:1' ? 'square' : 'portrait'} thumbnail image for: ${prompt}. Make it visually striking, professional, and perfect for social media. Focus on bold colors, dynamic composition, and eye-catching elements.`
                                                    }]
                                                }],
                                                generationConfig: {
                                                    temperature: 0.9,
                                                    candidateCount: 1
                                                }
                                            })
                                        }
                                    );

                                    if (imageGenResponse.ok) {
                                        const data = await imageGenResponse.json();
                                        console.log('🎨 Gemini 2.5 Flash Image API Response:', data);

                                        // Check if we got actual image data in the response
                                        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
                                            const parts = data.candidates[0].content.parts;

                                            // Look for inline image data
                                            for (const part of parts) {
                                                if (part.inlineData && part.inlineData.data && part.inlineData.mimeType) {
                                                    console.log('🎉 SUCCESS! Gemini 2.5 Flash Image generated actual image!');
                                                    setExecutionMessage(`🎉 Real AI image generated successfully!`);

                                                    return {
                                                        image: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
                                                        generated: true,
                                                        type: 'image',
                                                        usedPrompt: prompt,
                                                        preview: `🎨 AI Generated: "${prompt.substring(0, 40)}..."`
                                                    };
                                                }
                                            }

                                            // If we got text response but no image, use it to enhance our canvas
                                            if (parts[0].text) {
                                                const aiDescription = parts[0].text;
                                                console.log('📝 Got AI description, enhancing canvas:', aiDescription);
                                                setExecutionMessage(`🤖 AI enhanced canvas generation`);

                                                // Use AI description to dramatically improve canvas generation
                                                const keywords = aiDescription.toLowerCase();

                                                // Much more sophisticated color selection based on AI analysis
                                                if (keywords.includes('dark') || keywords.includes('night') || keywords.includes('shadow') || keywords.includes('black')) {
                                                    colorIndex = 0; // Dark theme
                                                } else if (keywords.includes('vibrant') || keywords.includes('neon') || keywords.includes('bright') || keywords.includes('electric')) {
                                                    colorIndex = 1; // Vibrant theme
                                                } else if (keywords.includes('ocean') || keywords.includes('blue') || keywords.includes('cool') || keywords.includes('ice')) {
                                                    colorIndex = 2; // Cool theme
                                                } else if (keywords.includes('nature') || keywords.includes('green') || keywords.includes('forest') || keywords.includes('organic')) {
                                                    colorIndex = 3; // Nature theme
                                                } else if (keywords.includes('fire') || keywords.includes('warm') || keywords.includes('energy') || keywords.includes('orange')) {
                                                    colorIndex = 4; // Warm theme
                                                } else {
                                                    colorIndex = 5; // Cosmic theme
                                                }

                                                // Enhanced gradient with AI insights
                                                const selectedColors = colors[colorIndex];
                                                const enhancedGradient = ctx.createRadialGradient(
                                                    canvas.width * 0.3, canvas.height * 0.3, 0,
                                                    canvas.width * 0.7, canvas.height * 0.7, canvas.width * 0.8
                                                );
                                                enhancedGradient.addColorStop(0, selectedColors[0]);
                                                enhancedGradient.addColorStop(1, selectedColors[1]);
                                                ctx.fillStyle = enhancedGradient;
                                                ctx.fillRect(0, 0, canvas.width, canvas.height);

                                                // AI-driven pattern generation
                                                ctx.globalAlpha = 0.2;
                                                const patternDensity = keywords.includes('complex') || keywords.includes('detailed') ? 50 :
                                                                      keywords.includes('minimal') || keywords.includes('clean') ? 5 : 25;

                                                for (let i = 0; i < patternDensity; i++) {
                                                    const x = Math.random() * canvas.width;
                                                    const y = Math.random() * canvas.height;
                                                    const size = Math.random() * 100 + 30;

                                                    if (keywords.includes('geometric') || keywords.includes('tech') || keywords.includes('digital')) {
                                                        // Tech/geometric patterns
                                                        ctx.fillStyle = '#ffffff';
                                                        ctx.fillRect(x - size/2, y - size/2, size * 0.8, 4);
                                                        ctx.fillRect(x - 2, y - size/2, 4, size * 0.8);
                                                    } else if (keywords.includes('organic') || keywords.includes('nature') || keywords.includes('flowing')) {
                                                        // Organic patterns
                                                        ctx.fillStyle = 'rgba(255,255,255,0.6)';
                                                        ctx.beginPath();
                                                        ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
                                                        ctx.fill();
                                                    } else {
                                                        // Default artistic patterns
                                                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                                                        ctx.beginPath();
                                                        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
                                                        ctx.fill();
                                                    }
                                                }
                                                ctx.globalAlpha = 1;

                                                // Add "AI ENHANCED" badge
                                                ctx.font = 'bold 18px Arial';
                                                ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
                                                ctx.textAlign = 'center';
                                                ctx.fillText('✨ AI Enhanced Design', canvas.width / 2, canvas.height - 40);
                                            }
                                        }
                                    } else {
                                        const errorData = await imageGenResponse.text();
                                        console.error('Gemini 2.5 Flash Image API failed:', imageGenResponse.status, errorData);
                                        setExecutionMessage(`❌ Image API failed: ${imageGenResponse.status}. Using fallback.`);
                                    }
                                } catch (error) {
                                    console.error('Gemini 2.5 Flash Image API error:', error);
                                    setExecutionMessage('⚠️ Image generation error, using fallback canvas');
                                }
                            } else {
                                console.log('⚠️ No API key provided, using canvas generation');
                                setExecutionMessage('⚠️ Configure API key for real image generation');
                            }

                            await new Promise(resolve => setTimeout(resolve, 1000));
                            return {
                                image: canvas.toDataURL('image/png'),
                                generated: true,
                                type: 'image',
                                usedPrompt: prompt,
                                preview: `Generated from: "${prompt.substring(0, 40)}..."`
                            };

                        case 'geminiEditImage':
                            // Requires both image and prompt inputs
                            if (!inputData || !Array.isArray(inputData) || inputData.length < 2) {
                                throw new Error('❌ Gemini EditImage requires 2 inputs: Connect both an image source AND a prompt input.');
                            }

                            // Find image and prompt inputs
                            const imageInput = inputData.find(input => input.type === 'image');
                            const promptInput = inputData.find(input => input.type === 'prompt');

                            if (!imageInput) {
                                throw new Error('❌ No image input found! Connect an Image Input or generated image.');
                            }
                            if (!promptInput) {
                                throw new Error('❌ No prompt input found! Connect a Prompt Input node with editing instructions.');
                            }
                            if (!imageInput.image) {
                                throw new Error('❌ Invalid image data received.');
                            }
                            if (!promptInput.prompt || promptInput.prompt.trim() === '') {
                                throw new Error('❌ Empty editing prompt! Add text to your Prompt Input node.');
                            }

                            if (!apiKeys.gemini) {
                                throw new Error('❌ Gemini API key not configured! Please add your Gemini 2.5 key in API settings.');
                            }

                            console.log(`✅ Editing image with prompt: "${promptInput.prompt}"`);
                            setExecutionMessage(`🎨 Editing image with Gemini 2.5: "${promptInput.prompt.substring(0, 30)}..."`);

                            try {
                                // Convert image to base64 if it's a URL
                                let imageDataUrl = imageInput.image;
                                if (imageInput.image.startsWith('http')) {
                                    // For external URLs, we need to fetch and convert
                                    const response = await fetch(imageInput.image);
                                    const blob = await response.blob();
                                    imageDataUrl = await new Promise(resolve => {
                                        const reader = new FileReader();
                                        reader.onload = () => resolve(reader.result);
                                        reader.readAsDataURL(blob);
                                    });
                                }

                                // Call Gemini 2.5 Flash Image API for editing
                                const editResponse = await fetch(
                                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent`,
                                    {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'x-goog-api-key': apiKeys.gemini
                                        },
                                        body: JSON.stringify({
                                            contents: [{
                                                parts: [
                                                    {
                                                        text: `Edit this image: ${promptInput.prompt}. Make professional, high-quality edits that enhance the visual appeal while following the instructions precisely.`
                                                    },
                                                    {
                                                        inlineData: {
                                                            mimeType: imageDataUrl.includes('data:image/png') ? 'image/png' : 'image/jpeg',
                                                            data: imageDataUrl.split(',')[1] // Remove data URL prefix
                                                        }
                                                    }
                                                ]
                                            }],
                                            generationConfig: {
                                                temperature: 0.7,
                                                candidateCount: 1
                                            }
                                        })
                                    }
                                );

                                if (editResponse.ok) {
                                    const data = await editResponse.json();
                                    console.log('🎨 Gemini EditImage API Response:', data);

                                    // Check for edited image data
                                    if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
                                        const parts = data.candidates[0].content.parts;

                                        // Look for inline image data
                                        for (const part of parts) {
                                            if (part.inlineData && part.inlineData.data && part.inlineData.mimeType) {
                                                console.log('🎉 SUCCESS! Gemini 2.5 edited the image!');
                                                setExecutionMessage(`🎉 Image edited successfully!`);

                                                return {
                                                    image: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
                                                    edited: true,
                                                    type: 'image',
                                                    usedPrompt: promptInput.prompt,
                                                    originalImage: imageInput.preview || 'Original image',
                                                    preview: `🎨 Edited: "${promptInput.prompt.substring(0, 40)}..."`
                                                };
                                            }
                                        }

                                        // If no image returned, fall back to original with enhancement message
                                        console.log('⚠️ No edited image returned, API may not support editing yet');
                                        setExecutionMessage('⚠️ Image editing not available, applying enhancement...');

                                        // Apply canvas-based enhancement as fallback
                                        const canvas = document.createElement('canvas');
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        img.src = imageDataUrl;

                                        await new Promise(resolve => img.onload = resolve);

                                        canvas.width = img.width;
                                        canvas.height = img.height;
                                        const ctx = canvas.getContext('2d');

                                        // Draw original image
                                        ctx.drawImage(img, 0, 0);

                                        // Apply enhancement based on prompt keywords
                                        const prompt = promptInput.prompt.toLowerCase();

                                        if (prompt.includes('vibrant') || prompt.includes('colorful')) {
                                            // Increase saturation
                                            ctx.filter = 'saturate(1.3) contrast(1.1)';
                                            ctx.drawImage(canvas, 0, 0);
                                        } else if (prompt.includes('darker') || prompt.includes('shadow')) {
                                            ctx.filter = 'brightness(0.8) contrast(1.2)';
                                            ctx.drawImage(canvas, 0, 0);
                                        } else if (prompt.includes('brighter') || prompt.includes('light')) {
                                            ctx.filter = 'brightness(1.2) contrast(1.1)';
                                            ctx.drawImage(canvas, 0, 0);
                                        } else {
                                            // General enhancement
                                            ctx.filter = 'contrast(1.1) saturate(1.1) brightness(1.05)';
                                            ctx.drawImage(canvas, 0, 0);
                                        }

                                        return {
                                            image: canvas.toDataURL('image/png'),
                                            edited: true,
                                            type: 'image',
                                            usedPrompt: promptInput.prompt,
                                            preview: `⚡ Enhanced: "${promptInput.prompt.substring(0, 40)}..."`
                                        };
                                    }
                                } else {
                                    const errorData = await editResponse.text();
                                    console.error('Gemini EditImage API failed:', editResponse.status, errorData);
                                    throw new Error(`Gemini EditImage API failed: ${editResponse.status}`);
                                }
                            } catch (error) {
                                console.error('Gemini EditImage Error:', error);
                                throw error;
                            }

                        case 'briaRemove':
                            if (!inputData) {
                                throw new Error('❌ No image connected! Connect an image source.');
                            }
                            if (inputData.type !== 'image') {
                                throw new Error(`❌ Wrong input type! Expected image, got ${inputData.type}.`);
                            }
                            if (!inputData.image) {
                                throw new Error('❌ Invalid image data received.');
                            }

                            if (!apiKeys.falai) {
                                throw new Error('❌ FalAI API key not configured! Please add your FalAI key in API settings.');
                            }

                            setExecutionMessage('🎨 Removing background with BRIA RMBG 2.0...');

                            try {
                                // First convert the base64 image to a blob and upload it
                                const response = await fetch(inputData.image);
                                const blob = await response.blob();

                                // Upload to FalAI storage first
                                const uploadResponse = await fetch('https://fal.run/fal-ai/bria/background/remove', {
                                    method: 'POST',
                                    headers: {
                                        'Authorization': `Key ${apiKeys.falai}`,
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        image_url: inputData.image, // Direct base64 image
                                        sync_mode: true
                                    })
                                });

                                if (!uploadResponse.ok) {
                                    const errorText = await uploadResponse.text();
                                    console.error('BRIA API Error:', uploadResponse.status, errorText);
                                    throw new Error(`BRIA API failed: ${uploadResponse.status}`);
                                }

                                const result = await uploadResponse.json();
                                console.log('✅ BRIA Background Removal Success:', result);

                                if (result.image && result.image.url) {
                                    setExecutionMessage('✅ Background removed successfully!');
                                    return {
                                        image: result.image.url,
                                        transparent: true,
                                        type: 'image',
                                        preview: 'BRIA: Background removed',
                                        width: result.image.width,
                                        height: result.image.height
                                    };
                                } else {
                                    throw new Error('No image returned from BRIA API');
                                }

                            } catch (error) {
                                console.error('BRIA Background Removal Error:', error);

                                // Fallback: Simple canvas-based background removal simulation
                                setExecutionMessage('⚠️ BRIA API unavailable, using fallback processing...');

                                const canvas = document.createElement('canvas');
                                const img = new Image();
                                img.crossOrigin = 'anonymous';

                                return new Promise((resolve, reject) => {
                                    img.onload = () => {
                                        canvas.width = img.width;
                                        canvas.height = img.height;
                                        const ctx = canvas.getContext('2d');

                                        // Draw the image
                                        ctx.drawImage(img, 0, 0);

                                        // Simple edge detection and background removal simulation
                                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                        const data = imageData.data;

                                        // Simple background removal by making similar colors transparent
                                        for (let i = 0; i < data.length; i += 4) {
                                            const r = data[i];
                                            const g = data[i + 1];
                                            const b = data[i + 2];

                                            // Simple heuristic: if color is very similar to corners, make transparent
                                            const isBackground = (
                                                Math.abs(r - g) < 30 && Math.abs(g - b) < 30 && Math.abs(r - b) < 30
                                            ) && (r + g + b > 600 || r + g + b < 150);

                                            if (isBackground) {
                                                data[i + 3] = 0; // Make transparent
                                            }
                                        }

                                        ctx.putImageData(imageData, 0, 0);

                                        resolve({
                                            image: canvas.toDataURL('image/png'),
                                            transparent: true,
                                            type: 'image',
                                            preview: '⚠️ Fallback: Background removal'
                                        });
                                    };

                                    img.onerror = () => {
                                        reject(new Error('Failed to load image for processing'));
                                    };

                                    img.src = inputData.image;
                                });
                            }

                        case 'textOverlay':
                            setExecutionMessage('📝 Creating advanced text overlay with positioning...');

                            const overlayCanvas = document.createElement('canvas');
                            overlayCanvas.width = 1920;
                            overlayCanvas.height = 1080;
                            const overlayCtx = overlayCanvas.getContext('2d');

                            // Check for input image
                            const overlayInput = inputData;

                            if (overlayInput?.image) {
                                console.log('✅ Text overlay with background image');
                                const img = new Image();
                                img.crossOrigin = 'anonymous';
                                img.src = overlayInput.image;
                                await new Promise(resolve => img.onload = resolve);
                                overlayCtx.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
                            } else {
                                console.log('✅ Text overlay standalone (transparent background)');
                                // Keep background transparent for standalone text overlays
                                if (node.parameters.backgroundColor && node.parameters.backgroundColor !== 'transparent') {
                                    overlayCtx.fillStyle = node.parameters.backgroundColor;
                                    overlayCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                                }
                                // If transparent, canvas starts transparent automatically
                            }

                            // Calculate position based on percentage
                            const positionX = (node.parameters.positionX || 50) / 100; // Convert to 0-1
                            const positionY = (node.parameters.positionY || 50) / 100; // Convert to 0-1
                            const textX = overlayCanvas.width * positionX;
                            const textY = overlayCanvas.height * positionY;

                            // Set text alignment
                            const alignment = node.parameters.alignment || 'center';
                            overlayCtx.textAlign = alignment;
                            overlayCtx.textBaseline = 'middle';

                            // Draw text with advanced positioning
                            const fontSize = node.parameters.fontSize || 72;
                            const textContent = node.parameters.text || 'TEXT';

                            overlayCtx.font = `bold ${fontSize}px Arial`;

                            // Add text shadow/stroke for better visibility
                            if (node.parameters.strokeColor && node.parameters.strokeColor !== 'transparent') {
                                overlayCtx.strokeStyle = node.parameters.strokeColor;
                                overlayCtx.lineWidth = Math.max(fontSize / 15, 2);
                                overlayCtx.strokeText(textContent, textX, textY);
                            }

                            // Main text
                            overlayCtx.fillStyle = node.parameters.color || '#FFFFFF';
                            overlayCtx.fillText(textContent, textX, textY);

                            // Add positioning indicator (small dot) for debugging
                            if (overlayInput?.image) { // Only show if there's a background
                                overlayCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                                overlayCtx.beginPath();
                                overlayCtx.arc(textX, textY, 4, 0, Math.PI * 2);
                                overlayCtx.fill();
                            }

                            await new Promise(resolve => setTimeout(resolve, 500));
                            return {
                                image: overlayCanvas.toDataURL('image/png'),
                                overlay: true,
                                transparent: !overlayInput?.image && node.parameters.backgroundColor === 'transparent',
                                type: 'image',
                                positionX: Math.round(positionX * 100),
                                positionY: Math.round(positionY * 100),
                                preview: `"${textContent}" at ${Math.round(positionX * 100)}%, ${Math.round(positionY * 100)}%`
                            };

                        case 'layerFusion':
                            console.log('🔍 Layer Fusion Debug - Input Data:', inputData);

                            if (!inputData) {
                                throw new Error('❌ No layers connected! Connect 2 or more image sources for layer fusion.');
                            }

                            setExecutionMessage('🎨 Advanced layer fusion with transparency support...');

                            // Handle both single and multiple inputs with detailed logging
                            let layers;
                            if (Array.isArray(inputData)) {
                                layers = inputData.filter(item => item && item.image); // Filter out invalid entries
                                console.log(`📋 Multiple inputs: ${inputData.length} total, ${layers.length} valid image layers`);
                            } else if (inputData.image) {
                                layers = [inputData];
                                console.log('📋 Single input converted to array');
                            } else {
                                console.error('❌ Invalid input data structure:', inputData);
                                throw new Error('❌ Invalid input data - no valid images found.');
                            }

                            if (layers.length === 0) {
                                throw new Error('❌ No valid image layers to fuse. Make sure all connected nodes have generated/output images.');
                            }

                            console.log('🎯 Layer details:', layers.map(l => ({
                                type: l.type,
                                transparent: l.transparent,
                                overlay: l.overlay,
                                preview: l.preview?.substring(0, 30) || 'No preview'
                            })));

                            if (layers.length === 1) {
                                console.log('⚠️ Only one valid layer provided, passing through as-is');
                                setExecutionMessage('⚠️ Only one layer - no fusion needed');
                                return {
                                    image: layers[0].image,
                                    fused: false,
                                    type: 'image',
                                    preview: 'Single layer (pass-through)'
                                };
                            }

                            console.log(`✅ Fusing ${layers.length} layers with transparency support`);

                            const fusionCanvas = document.createElement('canvas');
                            fusionCanvas.width = 1920;
                            fusionCanvas.height = 1080;
                            const fusionCtx = fusionCanvas.getContext('2d');

                            // Sort layers based on user preference
                            let sortedLayers;
                            if (node.parameters.layerOrder === 'input-order') {
                                sortedLayers = [...layers]; // Keep original order
                                console.log('Using input order for layers');
                            } else {
                                // Smart sorting: background images first, then overlays
                                sortedLayers = layers.sort((a, b) => {
                                    const aIsOverlay = a.transparent || a.overlay;
                                    const bIsOverlay = b.transparent || b.overlay;
                                    if (aIsOverlay && !bIsOverlay) return 1; // a goes after b
                                    if (!aIsOverlay && bIsOverlay) return -1; // a goes before b
                                    return 0; // maintain order
                                });
                                console.log('Using smart order for layers');
                            }

                            console.log('Layer order:', sortedLayers.map(l => l.preview || l.type));

                            let layerIndex = 0;
                            for (const layer of sortedLayers) {
                                if (layer?.image) {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';

                                    try {
                                        img.src = layer.image;
                                        await new Promise((resolve, reject) => {
                                            img.onload = resolve;
                                            img.onerror = reject;
                                        });

                                        setExecutionMessage(`🎨 Processing layer ${layerIndex + 1}/${layers.length}...`);

                                        // Set appropriate blend mode based on layer type
                                        if (layer.transparent || layer.overlay) {
                                            // For transparent overlays, use source-over to preserve transparency
                                            fusionCtx.globalCompositeOperation = 'source-over';
                                            console.log(`Layer ${layerIndex + 1}: Transparent overlay mode`);
                                        } else {
                                            // For background images, use the configured blend mode
                                            fusionCtx.globalCompositeOperation = node.parameters.blendMode || 'source-over';
                                            console.log(`Layer ${layerIndex + 1}: Background with blend mode '${node.parameters.blendMode || 'source-over'}'`);
                                        }

                                        // Check if this is a text overlay with positioning info
                                        if (layer.positionX !== undefined && layer.positionY !== undefined && layer.transparent) {
                                            console.log(`Layer ${layerIndex + 1}: Positioned text overlay at ${layer.positionX}%, ${layer.positionY}%`);

                                            // Calculate position while preserving aspect ratio
                                            const aspectRatio = img.width / img.height;
                                            let drawWidth = img.width;
                                            let drawHeight = img.height;

                                            // Scale if image is too large
                                            if (drawWidth > fusionCanvas.width || drawHeight > fusionCanvas.height) {
                                                const scaleX = fusionCanvas.width / drawWidth;
                                                const scaleY = fusionCanvas.height / drawHeight;
                                                const scale = Math.min(scaleX, scaleY);
                                                drawWidth *= scale;
                                                drawHeight *= scale;
                                            }

                                            const drawX = (layer.positionX / 100) * fusionCanvas.width - drawWidth / 2;
                                            const drawY = (layer.positionY / 100) * fusionCanvas.height - drawHeight / 2;

                                            fusionCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                                        } else {
                                            // Standard layer - fit to canvas
                                            if (layerIndex === 0 || !layer.transparent) {
                                                // Background layer - stretch to fill
                                                fusionCtx.drawImage(img, 0, 0, fusionCanvas.width, fusionCanvas.height);
                                                console.log(`Layer ${layerIndex + 1}: Background layer (stretched to fit)`);
                                            } else {
                                                // Overlay layer - center and preserve aspect ratio
                                                const aspectRatio = img.width / img.height;
                                                const canvasRatio = fusionCanvas.width / fusionCanvas.height;

                                                let drawWidth, drawHeight, drawX, drawY;

                                                if (aspectRatio > canvasRatio) {
                                                    // Image is wider - fit to width
                                                    drawWidth = fusionCanvas.width;
                                                    drawHeight = fusionCanvas.width / aspectRatio;
                                                    drawX = 0;
                                                    drawY = (fusionCanvas.height - drawHeight) / 2;
                                                } else {
                                                    // Image is taller - fit to height
                                                    drawHeight = fusionCanvas.height;
                                                    drawWidth = fusionCanvas.height * aspectRatio;
                                                    drawX = (fusionCanvas.width - drawWidth) / 2;
                                                    drawY = 0;
                                                }

                                                fusionCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                                                console.log(`Layer ${layerIndex + 1}: Overlay layer (aspect ratio preserved)`);
                                            }
                                        }

                                        layerIndex++;
                                    } catch (error) {
                                        console.error(`Failed to load layer ${layerIndex + 1}:`, error);
                                        // Continue with other layers
                                        layerIndex++;
                                    }
                                }
                            }

                            await new Promise(resolve => setTimeout(resolve, 300));

                            setExecutionMessage(`✅ Successfully fused ${layers.length} layers!`);

                            return {
                                image: fusionCanvas.toDataURL('image/png'),
                                fused: true,
                                type: 'image',
                                layers: layers.length,
                                transparentLayers: layers.filter(l => l.transparent || l.overlay).length,
                                preview: `🎨 ${layers.length} layers fused (${layers.filter(l => l.transparent || l.overlay).length} transparent)`
                            };

                        case 'export':
                            if (!inputData) {
                                throw new Error('❌ No image connected! Connect an image source to export.');
                            }
                            if (inputData.type !== 'image') {
                                throw new Error(`❌ Wrong input type! Expected image, got ${inputData.type}.`);
                            }
                            if (!inputData.image) {
                                throw new Error('❌ Invalid image data for export.');
                            }

                            setExecutionMessage('💾 Exporting thumbnail...');

                            const exportCanvas = document.createElement('canvas');
                            exportCanvas.width = node.parameters.width || 1920;
                            exportCanvas.height = node.parameters.height || 1080;
                            const exportCtx = exportCanvas.getContext('2d');

                            const img = new Image();
                            img.src = inputData.image;
                            await new Promise(resolve => img.onload = resolve);
                            exportCtx.drawImage(img, 0, 0, exportCanvas.width, exportCanvas.height);

                            // Download the image
                            exportCanvas.toBlob((blob) => {
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `thumbnail-${Date.now()}.${node.parameters.format || 'png'}`;
                                a.click();
                                URL.revokeObjectURL(url);
                            }, `image/${node.parameters.format || 'png'}`, (node.parameters.quality || 95) / 100);

                            await new Promise(resolve => setTimeout(resolve, 500));
                            return {
                                exported: true,
                                downloadComplete: true,
                                type: 'export',
                                preview: 'File downloaded'
                            };

                        case 'deepgramTranscribe':
                            if (!inputData) {
                                throw new Error('❌ No audio input connected! Connect an Audio Input node to transcribe.');
                            }
                            if (inputData.type !== 'audio') {
                                throw new Error(`❌ Wrong input type! Expected audio, got ${inputData.type}. Connect an Audio Input node.`);
                            }
                            if (!inputData.audioFile) {
                                throw new Error('❌ No audio file to transcribe!');
                            }

                            if (!apiKeys.deepgram) {
                                throw new Error('❌ Deepgram API key not configured! Please add your Deepgram key in API settings.');
                            }

                            setExecutionMessage('🎙️ Transcribing audio with Deepgram...');

                            try {
                                // Prepare audio data for Deepgram API
                                let audioData;
                                let contentType = 'audio/*';

                                // If we have a file blob, use it directly
                                if (inputData.audioFile instanceof File || inputData.audioFile instanceof Blob) {
                                    audioData = inputData.audioFile;
                                    contentType = inputData.audioFile.type || 'audio/*';
                                } else if (typeof inputData.audioFile === 'string' && inputData.audioFile.startsWith('data:')) {
                                    // Convert data URL to blob
                                    const response = await fetch(inputData.audioFile);
                                    const blob = await response.blob();
                                    audioData = blob;
                                    contentType = blob.type || 'audio/*';
                                } else {
                                    throw new Error('❌ Invalid audio file format. Please upload a valid audio file.');
                                }

                                // Call Deepgram transcription API with correct format
                                const transcriptionResponse = await fetch('https://api.deepgram.com/v1/listen', {
                                    method: 'POST',
                                    headers: {
                                        'Authorization': `Token ${apiKeys.deepgram}`,
                                        'Content-Type': contentType
                                    },
                                    body: audioData
                                });

                                if (!transcriptionResponse.ok) {
                                    const errorText = await transcriptionResponse.text();
                                    console.error('Deepgram API Error:', transcriptionResponse.status, errorText);
                                    throw new Error(`Deepgram API failed: ${transcriptionResponse.status}`);
                                }

                                const transcriptionResult = await transcriptionResponse.json();
                                console.log('✅ Deepgram Transcription Success:', transcriptionResult);

                                // Extract transcribed text
                                let transcribedText = '';
                                if (transcriptionResult.results &&
                                    transcriptionResult.results.channels &&
                                    transcriptionResult.results.channels[0] &&
                                    transcriptionResult.results.channels[0].alternatives &&
                                    transcriptionResult.results.channels[0].alternatives[0]) {
                                    transcribedText = transcriptionResult.results.channels[0].alternatives[0].transcript;
                                }

                                if (!transcribedText || transcribedText.trim() === '') {
                                    throw new Error('❌ No transcription result from Deepgram. Audio might be empty or unclear.');
                                }

                                setExecutionMessage('✅ Audio transcribed successfully!');

                                return {
                                    type: 'text',
                                    text: transcribedText,
                                    transcribed: true,
                                    confidence: transcriptionResult.results?.channels?.[0]?.alternatives?.[0]?.confidence || 0,
                                    preview: `🎙️ Transcribed: "${transcribedText.substring(0, 60)}${transcribedText.length > 60 ? '...' : ''}"`
                                };

                            } catch (error) {
                                console.error('Deepgram Transcription Error:', error);

                                // Check if it's a CORS/fetch error and provide fallback
                                if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                                    console.log('🔄 CORS error detected, using demo transcription fallback...');
                                    setExecutionMessage('⚠️ CORS limitation detected, using demo transcription...');

                                    // Simulate processing time
                                    await new Promise(resolve => setTimeout(resolve, 2000));

                                    // Generate demo transcription based on file name or generic content
                                    const fileName = inputData.fileName || 'audio';
                                    let demoTranscript = '';

                                    if (fileName.toLowerCase().includes('meeting')) {
                                        demoTranscript = "Hello everyone, welcome to today's meeting. Let's discuss the quarterly results and our upcoming project milestones. The team has made significant progress this quarter.";
                                    } else if (fileName.toLowerCase().includes('interview')) {
                                        demoTranscript = "Thank you for taking the time to speak with us today. Could you start by telling us about your background and experience in this field?";
                                    } else if (fileName.toLowerCase().includes('presentation')) {
                                        demoTranscript = "Good morning everyone. Today I'll be presenting our latest findings and recommendations for the upcoming product launch strategy.";
                                    } else {
                                        demoTranscript = "This is a demo transcription. Due to CORS restrictions, Deepgram API cannot be called directly from the browser. In a production environment, you would need a server-side proxy to handle Deepgram API calls securely.";
                                    }

                                    setExecutionMessage('✅ Demo transcription completed (CORS limitation workaround)');

                                    return {
                                        type: 'text',
                                        text: demoTranscript,
                                        transcribed: true,
                                        isDemo: true,
                                        confidence: 0.95,
                                        preview: `🎙️ Demo: "${demoTranscript.substring(0, 60)}${demoTranscript.length > 60 ? '...' : ''}"`
                                    };
                                }

                                // Re-throw other errors
                                throw error;
                            }

                        case 'llmTextCall':
                            if (!inputData || !Array.isArray(inputData) || inputData.length < 2) {
                                throw new Error('❌ LLM_Text_Call requires 2 inputs: Connect both text content AND a prompt input.');
                            }

                            // Find text and prompt inputs
                            const textInput = inputData.find(input => input.type === 'text');
                            const promptInputLLM = inputData.find(input => input.type === 'prompt');

                            if (!textInput) {
                                throw new Error('❌ No text input found! Connect a text source (like Deepgram Transcribe output).');
                            }
                            if (!promptInputLLM) {
                                throw new Error('❌ No prompt input found! Connect a Prompt Input node with instructions.');
                            }
                            if (!textInput.text || textInput.text.trim() === '') {
                                throw new Error('❌ Empty text content! Make sure your text source has content.');
                            }
                            if (!promptInputLLM.prompt || promptInputLLM.prompt.trim() === '') {
                                throw new Error('❌ Empty prompt! Add text to your Prompt Input node.');
                            }

                            if (!apiKeys.openai) {
                                throw new Error('❌ OpenAI API key not configured! Please add your OpenAI key in API settings.');
                            }

                            setExecutionMessage('🤖 Processing text with OpenAI...');

                            try {
                                // Call OpenAI Chat Completions API
                                const llmResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                                    method: 'POST',
                                    headers: {
                                        'Authorization': `Bearer ${apiKeys.openai}`,
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        model: 'gpt-3.5-turbo',
                                        messages: [
                                            {
                                                role: 'system',
                                                content: promptInputLLM.prompt
                                            },
                                            {
                                                role: 'user',
                                                content: textInput.text
                                            }
                                        ],
                                        max_tokens: 1000,
                                        temperature: 0.7
                                    })
                                });

                                if (!llmResponse.ok) {
                                    const errorText = await llmResponse.text();
                                    console.error('OpenAI API Error:', llmResponse.status, errorText);
                                    throw new Error(`OpenAI API failed: ${llmResponse.status}`);
                                }

                                const llmResult = await llmResponse.json();
                                console.log('✅ OpenAI LLM Response:', llmResult);

                                // Extract the generated text
                                let generatedText = '';
                                if (llmResult.choices && llmResult.choices[0] && llmResult.choices[0].message && llmResult.choices[0].message.content) {
                                    generatedText = llmResult.choices[0].message.content.trim();
                                }

                                if (!generatedText) {
                                    throw new Error('❌ No response from OpenAI. Please try again.');
                                }

                                setExecutionMessage('✅ Text processed successfully!');

                                return {
                                    type: 'text',
                                    text: generatedText,
                                    processed: true,
                                    usedPrompt: promptInputLLM.prompt,
                                    originalText: textInput.text,
                                    preview: `🤖 LLM: "${generatedText.substring(0, 60)}${generatedText.length > 60 ? '...' : ''}"`
                                };

                            } catch (error) {
                                console.error('OpenAI LLM Error:', error);
                                throw error;
                            }

                        case 'textDisplay':
                            if (!inputData) {
                                throw new Error('❌ No text input connected! Connect a text source to display.');
                            }
                            if (inputData.type !== 'text') {
                                throw new Error(`❌ Wrong input type! Expected text, got ${inputData.type}.`);
                            }
                            if (!inputData.text) {
                                throw new Error('❌ No text content to display!');
                            }

                            setExecutionMessage('👁 Displaying text content...');

                            // Store the text for display in the node's parameters
                            updateNodeParameters(node.id, {
                                displayedText: inputData.text,
                                lastUpdated: new Date().toLocaleString()
                            });

                            return {
                                type: 'text',
                                text: inputData.text,
                                displayed: true,
                                preview: `👁 Displaying: "${inputData.text.substring(0, 60)}${inputData.text.length > 60 ? '...' : ''}"`
                            };

                    */
                } catch (error) {
                    console.error(`❌ Error in ${node.type}:`, error);
                    throw error;
                }
            };

            // Execute single node with validation
            const executeSingleNode = async (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node) return;

                // Check if node requires input and has it
                if (nodeTypes[node.type].requiresInput && !hasRequiredInputs(nodeId)) {
                    alert(`❌ ${node.name} requires input connections!\n\nConnect the required input(s) before running this node.`);
                    return;
                }

                setExecutingNode(nodeId);
                setExecutionMessage(`Executing ${node.name}...`);

                setNodes(prev =>
                    prev.map(n =>
                        n.id === nodeId ? { ...n, status: 'running' } : n
                    )
                );

                try {
                    const result = await processNode(node);

                    setNodes(prev =>
                        prev.map(n =>
                            n.id === nodeId
                                ? { ...n, status: 'success', outputData: result }
                                : n
                        )
                    );

                    setExecutionMessage(`✅ ${node.name} executed successfully!`);

                } catch (error) {
                    setNodes(prev =>
                        prev.map(n =>
                            n.id === nodeId ? { ...n, status: 'error' } : n
                        )
                    );

                    alert(`❌ Error in ${node.name}:\n\n${error.message}`);
                    setExecutionMessage('');
                }

                setExecutingNode(null);

                setTimeout(() => {
                    setNodes(prev =>
                        prev.map(n =>
                            n.id === nodeId ? { ...n, status: 'idle' } : n
                        )
                    );
                    setExecutionMessage('');
                }, 3000);
            };

            // Execute entire workflow
            const executeWorkflow = async () => {
                if (nodes.length === 0) {
                    alert('No nodes to execute. Add nodes to create a workflow.');
                    return;
                }

                setIsExecuting(true);
                setExecutionProgress(0);

                // Build execution order
                const executionOrder = [];
                const visited = new Set();
                const startNodes = nodes.filter(node => {
                    const hasInput = connections.some(c => c.to === node.id);
                    return !hasInput || nodeTypes[node.type].inputs === 0;
                });

                const nodesToProcess = startNodes.length > 0 ? startNodes : nodes;
                const queue = [...nodesToProcess.map(n => n.id)];

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    if (!visited.has(nodeId)) {
                        visited.add(nodeId);
                        executionOrder.push(nodeId);

                        const outgoing = connections.filter(c => c.from === nodeId);
                        outgoing.forEach(conn => {
                            if (!visited.has(conn.to)) {
                                queue.push(conn.to);
                            }
                        });
                    }
                }

                nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        executionOrder.push(node.id);
                    }
                });

                for (let i = 0; i < executionOrder.length; i++) {
                    const nodeId = executionOrder[i];
                    const node = nodes.find(n => n.id === nodeId);

                    setNodes(prev =>
                        prev.map(n =>
                            n.id === nodeId ? { ...n, status: 'running' } : n
                        )
                    );

                    try {
                        const result = await processNode(node);

                        setNodes(prev =>
                            prev.map(n =>
                                n.id === nodeId
                                    ? { ...n, status: 'success', outputData: result }
                                    : n
                            )
                        );

                    } catch (error) {
                        setNodes(prev =>
                            prev.map(n =>
                                n.id === nodeId ? { ...n, status: 'error' } : n
                            )
                        );

                        setExecutionMessage(`Error: ${error.message}`);

                        if (!confirm(`❌ Error in ${node.name}: ${error.message}\n\nContinue?`)) {
                            break;
                        }
                    }

                    setExecutionProgress(((i + 1) / executionOrder.length) * 100);
                }

                setIsExecuting(false);
                setExecutionMessage('Workflow completed!');

                setTimeout(() => {
                    setNodes(prev => prev.map(n => ({ ...n, status: 'idle' })));
                    setExecutionMessage('');
                }, 5000);
            };

            // Handle file upload
            const handleFileUpload = (e, nodeId) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        updateNodeParameters(nodeId, {
                            imageData: event.target.result,
                            fileName: file.name
                        });
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleAudioFileUpload = (e, nodeId) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('audio/')) {
                    // ✅ Convert to base64 for proper persistence (like images)
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        updateNodeParameters(nodeId, {
                            audioFile: event.target.result,  // Base64 data URL
                            audioFileName: file.name,
                            audioFileSize: file.size,
                            audioFileType: file.type
                        });
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleVideoFileUpload = (e, nodeId) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('video/')) {
                    // Store the file directly for downstream video nodes/export
                    updateNodeParameters(nodeId, {
                        videoFile: file,
                        videoFileName: file.name
                    });
                }
            };

            // Check if port is connected
            const isPortConnected = (nodeId, portType) => {
                if (portType === 'input') {
                    return connections.some(c => c.to === nodeId);
                } else {
                    return connections.some(c => c.from === nodeId);
                }
            };

            // Render connection
            const renderConnection = (connection) => {
                const fromNode = nodes.find(n => n.id === connection.from);
                const toNode = nodes.find(n => n.id === connection.to);

                if (!fromNode || !toNode) return null;

                const fromX = fromNode.position[0] + 220;
                const fromY = fromNode.position[1] + 50;
                const toX = toNode.position[0];
                const toY = toNode.position[1] + 50;
                const midX = (fromX + toX) / 2;

                return (
                    <svg
                        key={connection.id}
                        style={{
                            position: 'absolute',
                            left: 0,
                            top: 0,
                            width: '100%',
                            height: '100%',
                            pointerEvents: 'none',
                            transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`
                        }}
                    >
                        <path
                            d={`M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`}
                            className="connection-line"
                        />
                        <polygon
                            points={`${toX},${toY} ${toX - 8},${toY - 4} ${toX - 8},${toY + 4}`}
                            fill="#3b82f6"
                        />
                    </svg>
                );
            };

            // Render temp connection
            const renderTempConnection = () => {
                if (!tempConnection || !tempConnection.from) return null;

                const fromNode = nodes.find(n => n.id === tempConnection.from.nodeId);
                if (!fromNode) return null;

                const fromX = fromNode.position[0] + 220;
                const fromY = fromNode.position[1] + 50;
                const toX = tempConnection.to.x;
                const toY = tempConnection.to.y;
                const midX = (fromX + toX) / 2;

                return (
                    <svg
                        style={{
                            position: 'absolute',
                            left: 0,
                            top: 0,
                            width: '100%',
                            height: '100%',
                            pointerEvents: 'none',
                            transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`
                        }}
                    >
                        <path
                            d={`M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`}
                            className="connection-line"
                            strokeDasharray="5,5"
                            opacity="0.5"
                        />
                    </svg>
                );
            };

            useEffect(() => {
                document.addEventListener('mousemove', handleNodeDrag);
                document.addEventListener('mouseup', handleNodeMouseUp);
                document.addEventListener('mousemove', handleCanvasMouseMove);
                document.addEventListener('mouseup', handleCanvasMouseUp);

                return () => {
                    document.removeEventListener('mousemove', handleNodeDrag);
                    document.removeEventListener('mouseup', handleNodeMouseUp);
                    document.removeEventListener('mousemove', handleCanvasMouseMove);
                    document.removeEventListener('mouseup', handleCanvasMouseUp);
                };
            }, [isDragging, draggedNode, isPanning, isConnecting, connectingFrom, pan, zoom]);

            const filteredNodeTypes = Object.entries(nodeTypes).filter(([key, node]) =>
                node.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                node.category.toLowerCase().includes(searchQuery.toLowerCase())
            );

            const selectedNodeData = selectedNode ? nodes.find(n => n.id === selectedNode) : null;

            const [showAIBuilder, setShowAIBuilder] = useState(false);
            const [selectedWorkflowName, setSelectedWorkflowName] = useState('');

            return (
                <div className="app-container">
                    {/* API Panel */}
                    <APIPanel
                        isOpen={showAPIPanel}
                        onClose={() => setShowAPIPanel(false)}
                        apiKeys={apiKeys}
                        setApiKeys={setApiKeys}
                    />

                    {/* AI Builder Panel */}
                    <AIBuilderPanel
                        isOpen={showAIBuilder}
                        onClose={() => setShowAIBuilder(false)}
                        apiKeys={apiKeys}
                        nodes={nodes}
                        connections={connections}
                        addNode={addNode}
                        updateNodeParameters={updateNodeParameters}
                        setConnections={setConnections}
                    />

                    {/* Header */}
                    <div className="header">
                        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
                            <h1 style={{ fontSize: '20px', fontWeight: '600' }}>NLPFlow</h1>
                            <span style={{ color: '#888', fontSize: '14px' }}>
                                {apiKeys.gemini ? '✅ Gemini 2.5 Flash Image Ready' : '⚠️ Configure API Keys'}
                                {' | '}
                                {nodes.length} nodes
                            </span>
                        </div>
                        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
                            <button className="btn" onClick={() => setShowAIBuilder(true)}>
                                🤖 AI Builder
                            </button>
                            <button className="btn btn-settings" onClick={() => setShowAPIPanel(!showAPIPanel)}>
                                ⚙ API Settings
                            </button>
                            {/* Workflow actions */}
                            <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                <button className="btn" onClick={saveWorkflow}>💾 Save</button>
                                <div style={{ display: 'inline-flex', alignItems: 'center', gap: '6px' }}>
                                    <select className="property-input" style={{ width: '180px', height: '32px' }} value={selectedWorkflowName} onChange={(e) => { setSelectedWorkflowName(e.target.value); if (e.target.value) loadWorkflow(e.target.value); }}>
                                        <option value="">Load workflow…</option>
                                        {savedWorkflows.map(name => (
                                            <option key={name} value={name}>{name}</option>
                                        ))}
                                    </select>
                                    <button className="btn btn-stop" title="Delete selected workflow" onClick={() => selectedWorkflowName && deleteWorkflow(selectedWorkflowName)}>🗑</button>
                                </div>
                                <button className="btn btn-stop" onClick={clearCanvas}>🧹 Clear</button>
                            </div>
                            {isConnecting && (
                                <span style={{ color: '#3b82f6', fontSize: '14px' }}>
                                    Click input port to connect
                                </span>
                            )}
                            {!isExecuting ? (
                                <button className="btn" onClick={executeWorkflow}>
                                    ▶ Execute All
                                </button>
                            ) : (
                                <button className="btn btn-stop" onClick={() => setIsExecuting(false)}>
                                    ■ Stop
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="main-content">
                        {/* Sidebar */}
                        <div className="sidebar">
                            <div className="search-box">
                                <input
                                    type="text"
                                    className="search-input"
                                    placeholder="Search nodes..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                />
                            </div>
                            <div className="node-library">
                                {['Input', 'AI', 'Design', 'Output'].map(category => {
                                    const categoryNodes = filteredNodeTypes.filter(([_, node]) => node.category === category);
                                    if (categoryNodes.length === 0) return null;

                                    return (
                                        <div key={category} className="node-category">
                                            <div className="node-category-title">{category}</div>
                                            {categoryNodes.map(([key, node]) => (
                                                <div
                                                    key={key}
                                                    className="library-node"
                                                    onClick={() => addNode(key)}
                                                >
                                                    <span>{NodeIcons[node.icon]}</span>
                                                    <div>
                                                        <div style={{ fontWeight: '500', fontSize: '14px' }}>{node.name}</div>
                                                        <div style={{ fontSize: '12px', color: '#888' }}>{node.description}</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* Canvas */}
                        <div className="canvas-container" ref={canvasRef}>
                            <div
                                className={`workflow-canvas ${isPanning ? 'grabbing' : ''}`}
                                onMouseDown={handleCanvasMouseDown}
                            >
                                <div
                                    className="canvas-grid"
                                    style={{
                                        transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                                        backgroundSize: `${20 * zoom}px ${20 * zoom}px`
                                    }}
                                />

                                {/* Connections */}
                                {connections.map(renderConnection)}
                                {renderTempConnection()}

                                {/* Nodes */}
                                <div style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}>
                                    {nodes.map(node => {
                                        const nodeType = nodeTypes[node.type];
                                        const requiresInput = nodeType.requiresInput && !hasRequiredInputs(node.id);

                                        return (
                                            <div
                                                key={node.id}
                                                className={`node ${selectedNode === node.id ? 'selected' : ''}`}
                                                style={{
                                                    left: node.position[0],
                                                    top: node.position[1]
                                                }}
                                                onMouseDown={(e) => handleNodeMouseDown(e, node.id)}
                                                onClick={() => setSelectedNode(node.id)}
                                            >
                                                <div className="node-header" style={{ backgroundColor: nodeType.headerColor }}>
                                                    <span>{NodeIcons[nodeType.icon]}</span>
                                                    <span>{node.name}</span>
                                                    <button
                                                        className="node-execute"
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            executeSingleNode(node.id);
                                                        }}
                                                        disabled={executingNode === node.id || requiresInput}
                                                        title={requiresInput ? `Requires input connections` : ''}
                                                    >
                                                        {executingNode === node.id ? '⏳' : requiresInput ? '❌' : '▶'} Run
                                                    </button>
                                                </div>
                                                <div className="node-body">
                                                    {/* Show what the node contains/will use */}
                                                    {node.type === 'promptInput' && node.parameters.promptText && (
                                                        <div style={{ fontSize: '12px', color: '#93c5fd' }}>
                                                            📝 "{node.parameters.promptText.substring(0, 40)}..."
                                                        </div>
                                                    )}
                                                    {node.type === 'imageInput' && node.parameters.fileName && (
                                                        <div style={{ fontSize: '12px', color: '#93c5fd' }}>
                                                            📁 {node.parameters.fileName}
                                                        </div>
                                                    )}
                                                    {node.type === 'textOverlay' && node.parameters.text && (
                                                        <div style={{ fontSize: '12px', color: '#93c5fd' }}>
                                                            📝 "{node.parameters.text}"
                                                        </div>
                                                    )}
                                                    {node.type === 'geminiText2Image' && (
                                                        <div style={{ fontSize: '12px', color: '#a78bfa' }}>
                                                            🎨 Gemini 2.5 Flash Image - Aspect: {node.parameters.aspectRatio || '16:9'}
                                                        </div>
                                                    )}

                                                    {/* Show input requirements */}
                                                    {requiresInput && (
                                                        <div className="node-warning-info">
                                                            ⚠️ Needs input connection
                                                        </div>
                                                    )}

                                                    {/* Debug info showing what input was received */}
                                                    {node.debugInfo && (
                                                        <div className="node-debug-info">
                                                            📥 Input: {node.debugInfo.hasInput ?
                                                                `${node.debugInfo.inputType} - ${node.debugInfo.inputPreview}` :
                                                                'none'}
                                                        </div>
                                                    )}

                                                {/* Preview images */}
                                                {node.outputData?.image && (
                                                    <img
                                                        src={node.outputData.image}
                                                        className="node-preview"
                                                        alt="Output"
                                                        title={node.outputData.preview || 'Generated output'}
                                                    />
                                                )}
                                                {/* Preview audio */}
                                                {node.outputData?.type === 'audio' && (node.outputData.audioFile || node.outputData.url) && (
                                                    <audio
                                                        src={node.outputData.audioFile || node.outputData.url}
                                                        className="node-preview"
                                                        controls
                                                    />
                                                )}
                                                {/* Preview videos */}
                                                {node.outputData?.type === 'video' && (node.outputData.videoUrl || node.outputData.url || (node.outputData.video && node.outputData.video.url) || (node.outputData.data && node.outputData.data.video_url)) && (
                                                    <video
                                                        src={node.outputData.videoUrl || node.outputData.url || (node.outputData.video && node.outputData.video.url) || (node.outputData.data && node.outputData.data.video_url)}
                                                        className="node-preview"
                                                        controls
                                                        style={{ maxHeight: '140px' }}
                                                    />
                                                )}
                                                {node.type === 'imageInput' && node.parameters.imageData && !node.outputData && (
                                                    <img
                                                        src={node.parameters.imageData}
                                                        className="node-preview"
                                                        alt="Input"
                                                        title={node.parameters.fileName}
                                                    />
                                                )}
                                                </div>

                                                {/* Ports with connection indicators */}
                                                {nodeType.inputs > 0 && (
                                                    <div
                                                        className={`node-port input ${isPortConnected(node.id, 'input') ? 'connected' : ''}`}
                                                        onClick={(e) => handlePortClick(e, node.id, 'input')}
                                                        title="Input port"
                                                    />
                                                )}
                                                {nodeType.outputs > 0 && (
                                                    <div
                                                        className={`node-port output ${isPortConnected(node.id, 'output') ? 'connected' : ''}`}
                                                        onClick={(e) => handlePortClick(e, node.id, 'output')}
                                                        title="Output port"
                                                    />
                                                )}

                                                {/* Multiple input ports for Layer Fusion */}
                                                {node.type === 'layerFusion' && (
                                                    <>
                                                        <div
                                                            className="node-port input"
                                                            style={{ top: '30%' }}
                                                            onClick={(e) => handlePortClick(e, node.id, 'input')}
                                                            title="Layer input 2"
                                                        />
                                                        <div
                                                            className="node-port input"
                                                            style={{ top: '70%' }}
                                                            onClick={(e) => handlePortClick(e, node.id, 'input')}
                                                            title="Layer input 3"
                                                        />
                                                    </>
                                                )}

                                                {/* Status indicator */}
                                                <div className={`node-status-indicator ${node.status}`} />
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* Zoom controls */}
                            <div className="zoom-controls">
                                <button className="zoom-btn" onClick={() => setZoom(Math.min(zoom * 1.2, 3))}>
                                    +
                                </button>
                                <button className="zoom-btn" onClick={() => setZoom(Math.max(zoom * 0.8, 0.3))}>
                                    -
                                </button>
                                <button className="zoom-btn" onClick={() => { setZoom(1); setPan({ x: 0, y: 0 }); }}>
                                    ⊡
                                </button>
                                <div style={{ textAlign: 'center', fontSize: '12px', color: '#888', marginTop: '4px' }}>
                                    {Math.round(zoom * 100)}%
                                </div>
                            </div>

                            {/* Execution status */}
                            <div className={`execution-status ${(isExecuting || executionMessage) ? 'active' : ''}`}>
                                <div style={{ fontSize: '14px', marginBottom: '8px' }}>
                                    {executionMessage || 'Executing Workflow...'}
                                </div>
                                {isExecuting && (
                                    <>
                                        <div style={{ width: '250px', height: '4px', background: '#3e3e3e', borderRadius: '2px' }}>
                                            <div
                                                style={{
                                                    width: `${executionProgress}%`,
                                                    height: '100%',
                                                    background: '#3b82f6',
                                                    borderRadius: '2px',
                                                    transition: 'width 0.3s ease'
                                                }}
                                            />
                                        </div>
                                        <div style={{ fontSize: '12px', color: '#888', marginTop: '4px' }}>
                                            {Math.round(executionProgress)}% Complete
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Properties Panel */}
                        <div className="properties-panel">
                            {selectedNodeData ? (
                                <>
                                    <div className="property-group">
                                        <h3 style={{ fontSize: '16px', marginBottom: '12px' }}>
                                            {nodeTypes[selectedNodeData.type].name} Properties
                                        </h3>
                                        <div style={{ fontSize: '12px', color: '#888', marginBottom: '12px' }}>
                                            {nodeTypes[selectedNodeData.type].description}
                                        </div>
                                        {nodeTypes[selectedNodeData.type].requiresInput && !hasRequiredInputs(selectedNodeData.id) && (
                                            <div className="node-warning-info" style={{ marginBottom: '12px' }}>
                                                ⚠️ This node requires input connections to run
                                            </div>
                                        )}
                                        <button
                                            className="btn"
                                            style={{ width: '100%' }}
                                            onClick={() => executeSingleNode(selectedNodeData.id)}
                                            disabled={executingNode === selectedNodeData.id || (nodeTypes[selectedNodeData.type].requiresInput && !hasRequiredInputs(selectedNodeData.id))}
                                        >
                                            {executingNode === selectedNodeData.id ? '⏳ Processing...' : '▶ Execute This Node'}
                                        </button>
                                    </div>

                                    {/* Node-specific properties */}
                                    {/* Prompt Input removed; use Text Input instead */}

                                    {selectedNodeData.type === 'textInput' && (
                                        <div className="property-group">
                                            <div className="property-label">Text Content</div>
                                            <textarea
                                                className="property-input"
                                                value={selectedNodeData.parameters.text || ''}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { text: e.target.value })}
                                                placeholder="Paste or type text to feed into downstream nodes"
                                            />
                                            <div style={{ fontSize: '11px', color: '#888', marginTop: '4px' }}>
                                                💡 Useful for feeding transcripts or notes into LLM/Text nodes
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'geminiText2Image' && (
                                        <div className="property-group">
                                            <div className="property-label">Configuration</div>
                                            <div style={{ fontSize: '12px', color: '#a78bfa', marginBottom: '12px' }}>
                                                🔗 Text Source: {hasRequiredInputs(selectedNodeData.id) ?
                                                    'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div className="property-label">Aspect Ratio</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.aspectRatio || '16:9'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { aspectRatio: e.target.value })}
                                            >
                                                <option value="16:9">16:9 (Landscape)</option>
                                                <option value="1:1">1:1 (Square)</option>
                                                <option value="4:5">4:5 (Portrait)</option>
                                            </select>
                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-error-info" style={{ marginTop: '12px' }}>
                                                    ❌ Connect a Text Input node to provide the prompt for generation
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'imageInput' && (
                                        <div className="property-group">
                                            <div className="property-label">Image Source</div>
                                            <input
                                                type="file"
                                                accept="image/*"
                                                style={{ display: 'none' }}
                                                id={`file-${selectedNodeData.id}`}
                                                onChange={(e) => handleFileUpload(e, selectedNodeData.id)}
                                            />
                                            <label
                                                htmlFor={`file-${selectedNodeData.id}`}
                                                className="file-upload-area"
                                            >
                                                📤 Click to upload image
                                            </label>
                                            {selectedNodeData.parameters.fileName && (
                                                <div style={{ marginTop: '8px', fontSize: '12px', color: '#888' }}>
                                                    📁 {selectedNodeData.parameters.fileName}
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'audioInput' && (
                                        <div className="property-group">
                                            <div className="property-label">Audio Source</div>
                                            <input
                                                type="file"
                                                accept="audio/*,.mp3,.wav,.flac,.ogg,.m4a,.webm"
                                                style={{ display: 'none' }}
                                                id={`audio-file-${selectedNodeData.id}`}
                                                onChange={(e) => handleAudioFileUpload(e, selectedNodeData.id)}
                                            />
                                            <label
                                                htmlFor={`audio-file-${selectedNodeData.id}`}
                                                className="file-upload-area"
                                            >
                                                🎵 Click to upload audio file
                                            </label>
                                            {selectedNodeData.parameters.audioFileName && (
                                                <div style={{ marginTop: '8px', fontSize: '12px', color: '#888' }}>
                                                    🎵 {selectedNodeData.parameters.audioFileName}
                                                </div>
                                            )}
                                            <div style={{ fontSize: '11px', color: '#888', marginTop: '8px' }}>
                                                Supported formats: MP3, WAV, FLAC, OGG, M4A, WebM
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'videoInput' && (
                                        <div className="property-group">
                                            <div className="property-label">Video Source</div>
                                            <input
                                                type="file"
                                                accept="video/*,.mp4,.webm,.mov,.mkv"
                                                style={{ display: 'none' }}
                                                id={`video-file-${selectedNodeData.id}`}
                                                onChange={(e) => handleVideoFileUpload(e, selectedNodeData.id)}
                                            />
                                            <label
                                                htmlFor={`video-file-${selectedNodeData.id}`}
                                                className="file-upload-area"
                                            >
                                                🎬 Click to upload video file
                                            </label>
                                            {selectedNodeData.parameters.videoFileName && (
                                                <div style={{ marginTop: '8px', fontSize: '12px', color: '#888' }}>
                                                    🎬 {selectedNodeData.parameters.videoFileName}
                                                </div>
                                            )}
                                            <div style={{ fontSize: '11px', color: '#888', marginTop: '8px' }}>
                                                Supported formats: MP4, WebM, MOV, MKV
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'textDisplay' && (
                                        <div className="property-group">
                                            <div className="property-label">Text Display</div>
                                            <div style={{ fontSize: '11px', color: '#888', marginBottom: '12px' }}>
                                                Connect any text output to display it here
                                            </div>
                                            {selectedNodeData.parameters.displayedText ? (
                                                <div>
                                                    <div className="property-label">Current Text</div>
                                                    <div style={{
                                                        backgroundColor: '#2a2a2a',
                                                        border: '1px solid #404040',
                                                        borderRadius: '8px',
                                                        padding: '12px',
                                                        maxHeight: '200px',
                                                        overflowY: 'auto',
                                                        fontSize: '13px',
                                                        lineHeight: '1.4',
                                                        whiteSpace: 'pre-wrap',
                                                        wordBreak: 'break-word'
                                                    }}>
                                                        {selectedNodeData.parameters.displayedText}
                                                    </div>
                                                    {selectedNodeData.parameters.lastUpdated && (
                                                        <div style={{ fontSize: '10px', color: '#666', marginTop: '8px' }}>
                                                            Last updated: {selectedNodeData.parameters.lastUpdated}
                                                        </div>
                                                    )}
                                                </div>
                                            ) : (
                                                <div style={{
                                                    backgroundColor: '#2a2a2a',
                                                    border: '1px dashed #404040',
                                                    borderRadius: '8px',
                                                    padding: '20px',
                                                    textAlign: 'center',
                                                    color: '#888'
                                                }}>
                                                    No text connected yet
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'textOverlay' && (
                                        <div className="property-group">
                                            <div className="property-label">Text</div>
                                            <input
                                                type="text"
                                                className="property-input"
                                                value={selectedNodeData.parameters.text || ''}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { text: e.target.value })}
                                                placeholder="Enter overlay text..."
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Font Size</div>
                                            <input
                                                type="range"
                                                className="property-slider"
                                                min="20"
                                                max="150"
                                                value={selectedNodeData.parameters.fontSize || 72}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fontSize: e.target.value })}
                                            />
                                            <div style={{ fontSize: '12px', color: '#888' }}>
                                                {selectedNodeData.parameters.fontSize || 72}px
                                            </div>
                                            <div className="property-label" style={{ marginTop: '12px' }}>Text Color</div>
                                            <input
                                                type="color"
                                                value={selectedNodeData.parameters.color || '#FFFFFF'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { color: e.target.value })}
                                                style={{ width: '100%', height: '40px' }}
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Background</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.backgroundColor || 'transparent'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { backgroundColor: e.target.value })}
                                            >
                                                <option value="transparent">Transparent</option>
                                                <option value="#000000">Black</option>
                                                <option value="#FFFFFF">White</option>
                                                <option value="#FF0000">Red</option>
                                                <option value="#00FF00">Green</option>
                                                <option value="#0000FF">Blue</option>
                                            </select>

                                            <div className="property-label" style={{ marginTop: '16px' }}>🎯 Text Positioning</div>
                                            <div style={{ fontSize: '11px', color: '#888', marginBottom: '8px' }}>
                                                Position text anywhere on the canvas using X,Y coordinates (0-100%)
                                            </div>

                                            <div className="property-label" style={{ marginTop: '8px' }}>Horizontal Position (%)</div>
                                            <input
                                                type="range"
                                                className="property-slider"
                                                min="0"
                                                max="100"
                                                value={selectedNodeData.parameters.positionX || 50}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { positionX: parseInt(e.target.value) })}
                                            />
                                            <div style={{ fontSize: '12px', color: '#888' }}>
                                                {selectedNodeData.parameters.positionX || 50}% (0=Left, 50=Center, 100=Right)
                                            </div>

                                            <div className="property-label" style={{ marginTop: '12px' }}>Vertical Position (%)</div>
                                            <input
                                                type="range"
                                                className="property-slider"
                                                min="0"
                                                max="100"
                                                value={selectedNodeData.parameters.positionY || 50}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { positionY: parseInt(e.target.value) })}
                                            />
                                            <div style={{ fontSize: '12px', color: '#888' }}>
                                                {selectedNodeData.parameters.positionY || 50}% (0=Top, 50=Middle, 100=Bottom)
                                            </div>

                                            <div className="property-label" style={{ marginTop: '12px' }}>Text Alignment</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.alignment || 'center'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { alignment: e.target.value })}
                                            >
                                                <option value="left">Left Aligned</option>
                                                <option value="center">Center Aligned</option>
                                                <option value="right">Right Aligned</option>
                                            </select>

                                            <div style={{
                                                fontSize: '11px',
                                                color: '#10b981',
                                                marginTop: '8px',
                                                padding: '6px',
                                                background: 'rgba(16, 185, 129, 0.1)',
                                                borderRadius: '4px'
                                            }}>
                                                💡 Tip: Use transparent background for overlays that can be layered on other images!
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'geminiEditImage' && (
                                        <div className="property-group">
                                            <div className="property-label">Image Editing Configuration</div>
                                            <div style={{ fontSize: '12px', color: '#a78bfa', marginBottom: '12px' }}>
                                                🔗 Inputs Required: Image + Prompt ({hasRequiredInputs(selectedNodeData.id) ?
                                                    'Connected (✓)' : 'Not connected (❌)'})
                                            </div>
                                            <div style={{ fontSize: '11px', color: '#888', marginBottom: '12px' }}>
                                                Connect an image source AND a prompt input with editing instructions.
                                            </div>

                                            <div className="property-label">Edit Instructions (Prompt)</div>
                                            <textarea
                                                className="property-input"
                                                value={selectedNodeData.parameters.editPrompt || ''}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { editPrompt: e.target.value })}
                                                placeholder="Enter editing instructions... e.g., 'Make this image more vibrant and add dramatic lighting'"
                                            />
                                            <div style={{ fontSize: '11px', color: '#888', marginTop: '4px' }}>
                                                💡 This is a fallback prompt. Connect a Prompt Input node for dynamic instructions.
                                            </div>

                                            <div style={{ marginTop: '12px' }}>
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', fontSize: '13px' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedNodeData.parameters.preserveAspectRatio !== false}
                                                        onChange={(e) => updateNodeParameters(selectedNodeData.id, { preserveAspectRatio: e.target.checked })}
                                                        style={{ accentColor: '#a855f7' }}
                                                    />
                                                    Preserve original aspect ratio
                                                </label>
                                            </div>

                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-error-info" style={{ marginTop: '12px' }}>
                                                    ❌ Connect both an image source AND a prompt input to enable editing
                                                </div>
                                            )}

                                            <div style={{
                                                fontSize: '11px',
                                                color: '#a855f7',
                                                marginTop: '12px',
                                                padding: '8px',
                                                background: 'rgba(168, 85, 247, 0.1)',
                                                borderRadius: '4px'
                                            }}>
                                                🎨 Pro Tip: Use specific editing instructions like "make more vibrant", "add dramatic shadows", or "change to nighttime scene" for best results!
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'falTextToVideo' && (
                                        <div className="property-group">
                                            <div className="property-label">Configuration</div>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Model</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.model || 'veo-3'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { model: e.target.value })}
                                            >
                                                <option value="veo-3">Veo 3</option>
                                                <option value="kling-2.5">Kling 2.5</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Resolution</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.resolution || '720p'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { resolution: e.target.value })}
                                            >
                                                <option value="576p">576p</option>
                                                <option value="720p">720p</option>
                                                <option value="1080p">1080p</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Duration (sec)</div>
                                            <input type="number" className="property-input" value={selectedNodeData.parameters.durationSec || 5}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { durationSec: parseInt(e.target.value) })} />
                                            <div className="property-label" style={{ marginTop: '8px' }}>FPS</div>
                                            <input type="number" className="property-input" value={selectedNodeData.parameters.fps || 24}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fps: parseInt(e.target.value) })} />
                                            <div className="property-label" style={{ marginTop: '8px' }}>Negative Prompt</div>
                                            <input type="text" className="property-input" value={selectedNodeData.parameters.negativePrompt || 'blur, distort, low quality'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { negativePrompt: e.target.value })} />
                                            <div className="property-label" style={{ marginTop: '8px' }}>CFG Scale</div>
                                            <input type="number" step="0.1" className="property-input" value={selectedNodeData.parameters.cfgScale || 0.5}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { cfgScale: parseFloat(e.target.value) })} />
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' }}>
                                                <input type="checkbox" checked={selectedNodeData.parameters.simulate !== false}
                                                    onChange={(e) => updateNodeParameters(selectedNodeData.id, { simulate: e.target.checked })} />
                                                Simulate if API unavailable
                                            </label>
                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-error-info" style={{ marginTop: '12px' }}>
                                                    ❌ Connect a Prompt or Text node to provide the prompt
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'falImageToVideo' && (
                                        <div className="property-group">
                                            <div className="property-label">Configuration</div>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Model</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.model || 'kling-2.5'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { model: e.target.value })}
                                            >
                                                <option value="kling-2.5">Kling 2.5</option>
                                                <option value="omnihuman">ByteDance Omnihuman (requires audio)</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Resolution</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.resolution || '720p'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { resolution: e.target.value })}
                                            >
                                                <option value="576p">576p</option>
                                                <option value="720p">720p</option>
                                                <option value="1080p">1080p</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Duration (sec)</div>
                                            <input type="number" className="property-input" value={selectedNodeData.parameters.durationSec || 4}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { durationSec: parseInt(e.target.value) })} />
                                            <div className="property-label" style={{ marginTop: '8px' }}>FPS</div>
                                            <input type="number" className="property-input" value={selectedNodeData.parameters.fps || 24}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fps: parseInt(e.target.value) })} />
                                            <div className="property-label" style={{ marginTop: '8px' }}>Source Image URL (optional)</div>
                                            <input type="text" className="property-input" placeholder="https://..."
                                                value={selectedNodeData.parameters.sourceImageUrl || ''}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { sourceImageUrl: e.target.value })} />
                                            {selectedNodeData.parameters.model === 'omnihuman' && (
                                                <>
                                                    <div className="property-label" style={{ marginTop: '8px' }}>Source Audio URL (required for Omnihuman)</div>
                                                    <input type="text" className="property-input" placeholder="https://..."
                                                        value={selectedNodeData.parameters.sourceAudioUrl || ''}
                                                        onChange={(e) => updateNodeParameters(selectedNodeData.id, { sourceAudioUrl: e.target.value })} />
                                                </>
                                            )}
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' }}>
                                                <input type="checkbox" checked={selectedNodeData.parameters.simulate !== false}
                                                    onChange={(e) => updateNodeParameters(selectedNodeData.id, { simulate: e.target.checked })} />
                                                Simulate if API unavailable
                                            </label>
                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-error-info" style={{ marginTop: '12px' }}>
                                                    ❌ Connect an image source (and audio for Omnihuman)
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'chatterboxTTS' && (
                                        <div className="property-group">
                                            <div className="property-label">Voice</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.voice || 'alloy'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { voice: e.target.value })}
                                            >
                                                <option value="alloy">Alloy</option>
                                                <option value="verse">Verse</option>
                                                <option value="bright">Bright</option>
                                                <option value="calm">Calm</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '8px' }}>Speed</div>
                                            <input type="number" className="property-input" step="0.1" value={selectedNodeData.parameters.speed || 1.0}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { speed: parseFloat(e.target.value) })} />
                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-error-info" style={{ marginTop: '12px' }}>
                                                    ❌ Connect a Text or Prompt node to synthesize speech
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'layerFusion' && (
                                        <div className="property-group">
                                            <div className="property-label">🎨 Layer Fusion Settings</div>
                                            <div style={{ fontSize: '12px', color: '#06b6d4', marginBottom: '12px' }}>
                                                🔗 Layers: {hasRequiredInputs(selectedNodeData.id) ?
                                                    'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div style={{ fontSize: '11px', color: '#888', marginBottom: '12px' }}>
                                                Connect multiple image sources to combine them. Background images go first, transparent overlays on top.
                                            </div>

                                            <div className="property-label">Blend Mode</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.blendMode || 'source-over'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { blendMode: e.target.value })}
                                            >
                                                <option value="source-over">Normal (Source Over)</option>
                                                <option value="multiply">Multiply</option>
                                                <option value="screen">Screen</option>
                                                <option value="overlay">Overlay</option>
                                                <option value="darken">Darken</option>
                                                <option value="lighten">Lighten</option>
                                                <option value="color-dodge">Color Dodge</option>
                                                <option value="color-burn">Color Burn</option>
                                                <option value="hard-light">Hard Light</option>
                                                <option value="soft-light">Soft Light</option>
                                                <option value="difference">Difference</option>
                                                <option value="exclusion">Exclusion</option>
                                            </select>
                                            <div style={{ fontSize: '11px', color: '#888', marginTop: '4px' }}>
                                                Affects how background layers blend together. Transparent overlays always use 'source-over'.
                                            </div>

                                            <div className="property-label" style={{ marginTop: '12px' }}>Layer Processing</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.layerOrder || 'smart'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { layerOrder: e.target.value })}
                                            >
                                                <option value="smart">Smart Order (backgrounds first, overlays on top)</option>
                                                <option value="input-order">Input Order (as connected)</option>
                                            </select>

                                            <div style={{ marginTop: '12px' }}>
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', fontSize: '13px' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedNodeData.parameters.preserveAspectRatio !== false}
                                                        onChange={(e) => updateNodeParameters(selectedNodeData.id, { preserveAspectRatio: e.target.checked })}
                                                        style={{ accentColor: '#06b6d4' }}
                                                    />
                                                    Preserve aspect ratio for overlay layers
                                                </label>
                                            </div>

                                            {!hasRequiredInputs(selectedNodeData.id) && (
                                                <div className="node-warning-info" style={{ marginTop: '12px' }}>
                                                    ⚠️ Connect 2 or more image sources to enable layer fusion
                                                    <div style={{ fontSize: '10px', marginTop: '4px' }}>
                                                        💡 Each image needs its own separate connection to this node
                                                    </div>
                                                </div>
                                            )}

                                            <div style={{
                                                fontSize: '11px',
                                                color: '#10b981',
                                                marginTop: '12px',
                                                padding: '8px',
                                                background: 'rgba(16, 185, 129, 0.1)',
                                                borderRadius: '4px'
                                            }}>
                                                💡 Pro Tip: Connect a background image (from Gemini or Image Input) as the first layer, then add transparent text overlays on top for perfect compositing!
                                            </div>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'export' && (
                                        <div className="property-group">
                                            <div className="property-label">Export Settings</div>
                                            <div style={{ fontSize: '12px', color: '#f97316', marginBottom: '12px' }}>
                                                🔗 Image Source: {hasRequiredInputs(selectedNodeData.id) ?
                                                    'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div className="property-label">Format</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.format || 'png'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { format: e.target.value })}
                                            >
                                                <option value="png">PNG</option>
                                                <option value="jpeg">JPEG</option>
                                                <option value="webp">WebP</option>
                                            </select>
                                            <div className="property-label" style={{ marginTop: '12px' }}>Width</div>
                                            <input
                                                type="number"
                                                className="property-input"
                                                value={selectedNodeData.parameters.width || 1920}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { width: parseInt(e.target.value) })}
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Height</div>
                                            <input
                                                type="number"
                                                className="property-input"
                                                value={selectedNodeData.parameters.height || 1080}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { height: parseInt(e.target.value) })}
                                            />
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'videoExport' && (
                                        <div className="property-group">
                                            <div className="property-label">Video Export</div>
                                            <div style={{ fontSize: '12px', color: '#f97316', marginBottom: '12px' }}>
                                                🔗 Video Source: {hasRequiredInputs(selectedNodeData.id) ? 'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div className="property-label">File name</div>
                                            <input
                                                type="text"
                                                className="property-input"
                                                value={selectedNodeData.parameters.fileName || 'nlpflow_video'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fileName: e.target.value })}
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Format</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.format || 'mp4'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { format: e.target.value })}
                                            >
                                                <option value="mp4">MP4</option>
                                                <option value="webm">WebM</option>
                                            </select>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'audioExport' && (
                                        <div className="property-group">
                                            <div className="property-label">Audio Export</div>
                                            <div style={{ fontSize: '12px', color: '#f97316', marginBottom: '12px' }}>
                                                🔗 Audio Source: {hasRequiredInputs(selectedNodeData.id) ? 'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div className="property-label">File name</div>
                                            <input
                                                type="text"
                                                className="property-input"
                                                value={selectedNodeData.parameters.fileName || 'nlpflow_audio'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fileName: e.target.value })}
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Format</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.format || 'wav'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { format: e.target.value })}
                                            >
                                                <option value="wav">WAV</option>
                                                <option value="mp3">MP3</option>
                                            </select>
                                        </div>
                                    )}

                                    {selectedNodeData.type === 'textExport' && (
                                        <div className="property-group">
                                            <div className="property-label">Text Export</div>
                                            <div style={{ fontSize: '12px', color: '#f97316', marginBottom: '12px' }}>
                                                🔗 Text Source: {hasRequiredInputs(selectedNodeData.id) ? 'Connected (✓)' : 'Not connected (❌)'}
                                            </div>
                                            <div className="property-label">File name</div>
                                            <input
                                                type="text"
                                                className="property-input"
                                                value={selectedNodeData.parameters.fileName || 'nlpflow_text'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { fileName: e.target.value })}
                                            />
                                            <div className="property-label" style={{ marginTop: '12px' }}>Format</div>
                                            <select
                                                className="property-select"
                                                value={selectedNodeData.parameters.format || 'txt'}
                                                onChange={(e) => updateNodeParameters(selectedNodeData.id, { format: e.target.value })}
                                            >
                                                <option value="txt">TXT</option>
                                                <option value="json">JSON</option>
                                            </select>
                                            {selectedNodeData.parameters.format === 'json' && (
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedNodeData.parameters.pretty !== false}
                                                        onChange={(e) => updateNodeParameters(selectedNodeData.id, { pretty: e.target.checked })}
                                                    />
                                                    Pretty-print JSON
                                                </label>
                                            )}
                                        </div>
                                    )}

                                    <div className="property-group">
                                        <button
                                            className="btn"
                                            style={{ width: '100%', background: '#ef4444' }}
                                            onClick={() => deleteNode(selectedNodeData.id)}
                                        >
                                            🗑 Delete Node
                                        </button>
                                    </div>
                                </>
                            ) : (
                                <div className="property-group">
                                    <div style={{ textAlign: 'center', color: '#888', padding: '40px 20px' }}>
                                        <div style={{ fontSize: '32px' }}>🎯</div>
                                        <div style={{ marginTop: '12px', marginBottom: '20px' }}>
                                            <strong>Robust Prompt Control</strong>
                                        </div>
                                        <div style={{ fontSize: '13px', textAlign: 'left' }}>
                                            <strong>1. Prompt → AI Flow:</strong><br/>
                                            • Add Prompt Input<br/>
                                            • Add Gemini Generate<br/>
                                            • Connect them<br/>
                                            • Run individually<br/><br/>

                                            <strong>2. Visual Feedback:</strong><br/>
                                            • Nodes show input status<br/>
                                            • Debug info shows data flow<br/>
                                            • Connected ports are green<br/><br/>

                                            <strong>3. Error Prevention:</strong><br/>
                                            • Required connections enforced<br/>
                                            • Clear error messages<br/>
                                            • No mysterious failures<br/>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ThumbnailGenerator />);
    </script>
</body>
</html>
